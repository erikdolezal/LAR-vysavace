window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "run", "modulename": "run", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "run.MainControl", "modulename": "run", "qualname": "MainControl", "kind": "class", "doc": "<p>MainControl class is responsible for managing the robot's main control loop,\nhandling  SLAM (Simultaneous Localization and Mapping),\npath planning, and velocity control.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>turtle (Turtlebot):</strong>  Instance of the Turtlebot class for robot control.</li>\n<li><strong>end_event (Event):</strong>  Event to signal the end of the program.</li>\n<li><strong>start_event (Event):</strong>  Event to signal the start of the mission.</li>\n<li><strong>velocity_control (VelocityControl):</strong>  Handles velocity commands for the robot.</li>\n<li><strong>camera (OnnxCamera):</strong>  Object detection class.</li>\n<li><strong>slam (UKF_SLAM):</strong>  SLAM classs.</li>\n<li><strong>odo (Odometry):</strong>  Odometry class.</li>\n<li><strong>path_planning (Planning):</strong>  Path planning  class for navigation.</li>\n</ul>\n\n<h6 id=\"methods\">Methods:</h6>\n\n<blockquote>\n  <p>__init__():\n      Initializes the MainControl class, sets up the robot, SLAM, and other components.\n  bumper_callback(msg):\n      Callback function triggered when the bumper is pressed.\n  button_callback(msg):\n      Callback function triggered when the button is pressed.\n  run():\n      Main control loop for the robot. Handles sensor data, SLAM updates,\n      path planning, and robot motion.</p>\n</blockquote>\n"}, {"fullname": "run.MainControl.turtle", "modulename": "run", "qualname": "MainControl.turtle", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "run.MainControl.end_event", "modulename": "run", "qualname": "MainControl.end_event", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "run.MainControl.start_event", "modulename": "run", "qualname": "MainControl.start_event", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "run.MainControl.velocity_control", "modulename": "run", "qualname": "MainControl.velocity_control", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "run.MainControl.camera", "modulename": "run", "qualname": "MainControl.camera", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "run.MainControl.slam", "modulename": "run", "qualname": "MainControl.slam", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "run.MainControl.odo", "modulename": "run", "qualname": "MainControl.odo", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "run.MainControl.path_planning", "modulename": "run", "qualname": "MainControl.path_planning", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "run.MainControl.slam_poses", "modulename": "run", "qualname": "MainControl.slam_poses", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "run.MainControl.points", "modulename": "run", "qualname": "MainControl.points", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "run.MainControl.ball", "modulename": "run", "qualname": "MainControl.ball", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "run.MainControl.bumper_callback", "modulename": "run", "qualname": "MainControl.bumper_callback", "kind": "function", "doc": "<p>Callback function triggered when the bumper state changes.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>msg:</strong>  A message object containing the state of the bumper.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">msg</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "run.MainControl.button_callback", "modulename": "run", "qualname": "MainControl.button_callback", "kind": "function", "doc": "<p>Callback function triggered by a button press event used for starting the mission.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>msg:</strong>  An object containing the state of the button.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">msg</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "run.MainControl.run", "modulename": "run", "qualname": "MainControl.run", "kind": "function", "doc": "<p>The <code>run</code> method is the main execution loop for the robot's operation. It handles sensor data processing,\nSLAM (Simultaneous Localization and Mapping), path planning, and velocity control. The method also\nvisualizes the SLAM process and generates a final plot of the robot's path and detected landmarks.\nThe method continuously runs until the robot is shut down or a goal is reached.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "algorithms", "modulename": "algorithms", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "algorithms.PathPlanning", "modulename": "algorithms.PathPlanning", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "algorithms.PathPlanning.Planning", "modulename": "algorithms.PathPlanning", "qualname": "Planning", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "algorithms.PathPlanning.Planning.objects", "modulename": "algorithms.PathPlanning", "qualname": "Planning.objects", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.PathPlanning.Planning.goal_targer", "modulename": "algorithms.PathPlanning", "qualname": "Planning.goal_targer", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.PathPlanning.Planning.ball_pos", "modulename": "algorithms.PathPlanning", "qualname": "Planning.ball_pos", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.PathPlanning.Planning.ball_path", "modulename": "algorithms.PathPlanning", "qualname": "Planning.ball_path", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.PathPlanning.Planning.robot_pos", "modulename": "algorithms.PathPlanning", "qualname": "Planning.robot_pos", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.PathPlanning.Planning.time_to_shoot", "modulename": "algorithms.PathPlanning", "qualname": "Planning.time_to_shoot", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.PathPlanning.Planning.create_path", "modulename": "algorithms.PathPlanning", "qualname": "Planning.create_path", "kind": "function", "doc": "<p>Returns next point in a path or robot path and ball path if test_alg is true</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>object_pos (list):</strong>  List of objects positions and classes</li>\n<li><strong>robot_pos (list):</strong>  Position of the robot</li>\n<li><strong>test_alg (bool):</strong>  If True, returns all paths for testing</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: Next point in the path for the robot to follow</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">object_pos</span>, </span><span class=\"param\"><span class=\"n\">robot_pos</span>, </span><span class=\"param\"><span class=\"n\">test_alg</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "algorithms.PathPlanning.Planning.clear_objects", "modulename": "algorithms.PathPlanning", "qualname": "Planning.clear_objects", "kind": "function", "doc": "<p>Clears all objectss.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "algorithms.PathPlanning.Planning.same_hading", "modulename": "algorithms.PathPlanning", "qualname": "Planning.same_hading", "kind": "function", "doc": "<p>Checks if the robot is in the same direction as the vector.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>vector (np.ndarray):</strong>  Vector to check</li>\n<li><strong>angle (float):</strong>  Angle of the robot</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if the robot is in the same direction as the vector, False otherwise</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">vector</span>, </span><span class=\"param\"><span class=\"n\">angle</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "algorithms.PathPlanning.Planning.turn_robot_around", "modulename": "algorithms.PathPlanning", "qualname": "Planning.turn_robot_around", "kind": "function", "doc": "<p>Turns the robot around by -90 degrees.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>center (np.ndarray):</strong>  Center of the robot</li>\n<li><strong>angle (float):</strong>  Angle of the robot</li>\n<li><strong>distance (float):</strong>  Scale of turning vector</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: New position to turn to.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">center</span>, </span><span class=\"param\"><span class=\"n\">angle</span>, </span><span class=\"param\"><span class=\"n\">distance</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "algorithms.PathPlanning.Planning.identify_objects", "modulename": "algorithms.PathPlanning", "qualname": "Planning.identify_objects", "kind": "function", "doc": "<p>Indenfify objects and add them to the objects list</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>objects_in (np.ndarray):</strong>  List of objects positions and classes</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>ErrorCodes: Error code for the outcome of the function</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">objects_in</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "algorithms.PathPlanning.Planning.solve_more_blue_tubes", "modulename": "algorithms.PathPlanning", "qualname": "Planning.solve_more_blue_tubes", "kind": "function", "doc": "<p>Solves the problem of more than 2 blue tubes by returning the first blue tube or the goal target if it exists</p>\n\n<h6 id=\"retuns\">Retuns:</h6>\n\n<blockquote>\n  <p>np.ndarray: Position of the blue tube or goal target</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "algorithms.PathPlanning.Planning.is_goal", "modulename": "algorithms.PathPlanning", "qualname": "Planning.is_goal", "kind": "function", "doc": "<p>Checks if the ball is in the goal.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if the ball is in the goal, False otherwise</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "algorithms.PathPlanning.Planning.generate_trajectory", "modulename": "algorithms.PathPlanning", "qualname": "Planning.generate_trajectory", "kind": "function", "doc": "<p>Gernerates a path from start to target point and avoids one obstacle point.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>start (np.ndarray):</strong>  Start point</li>\n<li><strong>target (np.ndarray):</strong>  Target point</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: Path points</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">start</span>, </span><span class=\"param\"><span class=\"n\">target</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "algorithms.PathPlanning.Planning.generate_way_around", "modulename": "algorithms.PathPlanning", "qualname": "Planning.generate_way_around", "kind": "function", "doc": "<p>Generates a path around the problem point by finding the shortest path through the tangent points.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>start (np.ndarray):</strong>  Start point</li>\n<li><strong>end (np.ndarray):</strong>  End point</li>\n<li><strong>problem (np.ndarray):</strong>  Problem point</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: Path points for the alternative path</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">start</span>, </span><span class=\"param\"><span class=\"n\">end</span>, </span><span class=\"param\"><span class=\"n\">problem</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "algorithms.PathPlanning.Planning.generate_shoot_path", "modulename": "algorithms.PathPlanning", "qualname": "Planning.generate_shoot_path", "kind": "function", "doc": "<p>Generates a shooting point for the robot and a path to the ball</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: Shooting point and overshoot point</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "algorithms.PathPlanning.Planning.check_colisions", "modulename": "algorithms.PathPlanning", "qualname": "Planning.check_colisions", "kind": "function", "doc": "<p>Checks if there are any collisions with the path between the start and end points and returns the collision point if there is one.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>path (np.ndarray):</strong>  Path points</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: Collision point if there is one, else None</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">path</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "algorithms.PathPlanning.Planning.check_colision_from_class", "modulename": "algorithms.PathPlanning", "qualname": "Planning.check_colision_from_class", "kind": "function", "doc": "<p>Checks for colision with specified class of objects and returns the colision point if there is one.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>path (np.ndarray):</strong>  Path points</li>\n<li><strong>data_class (DataClasses):</strong>  Class of objects</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: Collision point if there is one, else None</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">path</span>, </span><span class=\"param\"><span class=\"n\">data_class</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "algorithms.PathPlanning.Planning.point_distance_from_line", "modulename": "algorithms.PathPlanning", "qualname": "Planning.point_distance_from_line", "kind": "function", "doc": "<p>Calculates the perpendicular distance of a point from the line defined by points A and B.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>P (np.ndarray):</strong>  Point to check</li>\n<li><strong>A (np.ndarray):</strong>  Start point of the line</li>\n<li><strong>B (np.ndarray):</strong>  End point of the line</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>float: Distance from the point to the line</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">P</span>, </span><span class=\"param\"><span class=\"n\">A</span>, </span><span class=\"param\"><span class=\"n\">B</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "algorithms.PathPlanning.Planning.find_tangent_points", "modulename": "algorithms.PathPlanning", "qualname": "Planning.find_tangent_points", "kind": "function", "doc": "<p>Finds two tangent points from start point to circle.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>start (np.ndarray):</strong>  Start point</li>\n<li><strong>center (np.ndarray):</strong>  Center of the object</li>\n<li><strong>radius (float):</strong>  Radius of the object perimeter</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: First tangent point\n  np.ndarray: Second tangent point</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">start</span>, </span><span class=\"param\"><span class=\"n\">center</span>, </span><span class=\"param\"><span class=\"n\">radius</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "algorithms.PathPlanning.Planning.mat_rot", "modulename": "algorithms.PathPlanning", "qualname": "Planning.mat_rot", "kind": "function", "doc": "<p>Returns a rotation matrix for a given angle</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>angle (float):</strong>  Angle in radians</li>\n<li><strong>vector (np.ndarray):</strong>  Vector to rotate</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: Rotated vector</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">angle</span>, </span><span class=\"param\"><span class=\"n\">vector</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "algorithms.PathPlanning.Planning.path_length", "modulename": "algorithms.PathPlanning", "qualname": "Planning.path_length", "kind": "function", "doc": "<p>Calculates the total length of a line.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>float:</strong>  Length of the line.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">points</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "algorithms.PathPlanning.Planning.find_intersection", "modulename": "algorithms.PathPlanning", "qualname": "Planning.find_intersection", "kind": "function", "doc": "<p>Finds the intersection point of two lines defined by two points each.</p>\n\n<ol>\n<li>lineA: (lineA_a, lineA_b)</li>\n<li>lineB: (lineB_a, lineB_b)</li>\n<li>Returns the intersection point if exists, else None</li>\n</ol>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>lineA_a (np.ndarray):</strong>  Start point of line A</li>\n<li><strong>lineA_b (np.ndarray):</strong>  End point of line A</li>\n<li><strong>lineB_a (np.ndarray):</strong>  Start point of line B</li>\n<li><strong>lineB_b (np.ndarray):</strong>  End point of line B</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: Intersection point if exists, else None</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">lineA_a</span>, </span><span class=\"param\"><span class=\"n\">lineA_b</span>, </span><span class=\"param\"><span class=\"n\">lineB_a</span>, </span><span class=\"param\"><span class=\"n\">lineB_b</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "algorithms.PathPlanning.Planning.are_points_in_proximity", "modulename": "algorithms.PathPlanning", "qualname": "Planning.are_points_in_proximity", "kind": "function", "doc": "<p>Checks if two points are within a given proximity.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>point1 (np.ndarray):</strong>  First point</li>\n<li><strong>point2 (np.ndarray):</strong>  Second point</li>\n<li><strong>dis_check (float):</strong>  Distance threshold for proximity check</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if points are within proximity, False otherwise</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">point1</span>, </span><span class=\"param\"><span class=\"n\">point2</span>, </span><span class=\"param\"><span class=\"n\">dis_check</span><span class=\"o\">=</span><span class=\"mf\">0.2</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "algorithms.UKFSlam", "modulename": "algorithms.UKFSlam", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "algorithms.UKFSlam.UKF_SLAM", "modulename": "algorithms.UKFSlam", "qualname": "UKF_SLAM", "kind": "class", "doc": "<p>Unscented Kalman Filter SLAM for estimatin robots position nad mapping landmarks</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>x (np.ndarray):</strong>  State vector of the robot and landmarks.</li>\n<li><strong>P (np.ndarray):</strong>  Covariance matrix of the state.</li>\n<li><strong>data_cls (np.ndarray):</strong>  Array storing the classes of detected landmarks.</li>\n<li><strong>landmarks (np.ndarray):</strong>  Array of landmarks with their positions and classes.</li>\n<li><strong>alpha (float):</strong>  Scaling parameter for sigma points.</li>\n<li><strong>beta (float):</strong>  Parameter for incorporating prior knowledge of the distribution.</li>\n<li><strong>kappa (float):</strong>  Secondary scaling parameter for sigma points.</li>\n<li><strong>n (int):</strong>  Dimensionality of the state vector.</li>\n<li><strong>lambda_ (float):</strong>  Composite scaling parameter for sigma points.</li>\n<li><strong>Wm (np.ndarray):</strong>  Weights for the mean of sigma points.</li>\n<li><strong>Wc (np.ndarray):</strong>  Weights for the covariance of sigma points.</li>\n<li><strong>landmark_contestants (np.ndarray):</strong>  Temporary storage for potential landmarks.</li>\n</ul>\n\n<h6 id=\"methods\">Methods:</h6>\n\n<blockquote>\n  <p>__init__(x_size, alpha, beta, kappa):\n      Initializes the UKF_SLAM object with state size and filter parameters.\n  sigma_points(x, P):\n      Computes sigma points for the given state mean and covariance.\n  f(x, u):\n      State transition function for predicting the next state.\n  predict(u, old_u):\n      Performs the prediction step of the UKF using odometry data.\n  update(z, h, R):\n      Performs the update step of the UKF using camera detections.\n  data_association(percep_data):\n      Associates perceived data with existing landmarks.\n  update_from_detections(percep_data, time):\n      Updates the state and landmarks based on new detections.</p>\n</blockquote>\n"}, {"fullname": "algorithms.UKFSlam.UKF_SLAM.__init__", "modulename": "algorithms.UKFSlam", "qualname": "UKF_SLAM.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x_size</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">alpha</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">beta</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">kappa</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span>)</span>"}, {"fullname": "algorithms.UKFSlam.UKF_SLAM.x", "modulename": "algorithms.UKFSlam", "qualname": "UKF_SLAM.x", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.UKFSlam.UKF_SLAM.P", "modulename": "algorithms.UKFSlam", "qualname": "UKF_SLAM.P", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.UKFSlam.UKF_SLAM.data_cls", "modulename": "algorithms.UKFSlam", "qualname": "UKF_SLAM.data_cls", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.UKFSlam.UKF_SLAM.landmarks", "modulename": "algorithms.UKFSlam", "qualname": "UKF_SLAM.landmarks", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.UKFSlam.UKF_SLAM.alpha", "modulename": "algorithms.UKFSlam", "qualname": "UKF_SLAM.alpha", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.UKFSlam.UKF_SLAM.beta", "modulename": "algorithms.UKFSlam", "qualname": "UKF_SLAM.beta", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.UKFSlam.UKF_SLAM.kappa", "modulename": "algorithms.UKFSlam", "qualname": "UKF_SLAM.kappa", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.UKFSlam.UKF_SLAM.n", "modulename": "algorithms.UKFSlam", "qualname": "UKF_SLAM.n", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.UKFSlam.UKF_SLAM.lambda_", "modulename": "algorithms.UKFSlam", "qualname": "UKF_SLAM.lambda_", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.UKFSlam.UKF_SLAM.Wm", "modulename": "algorithms.UKFSlam", "qualname": "UKF_SLAM.Wm", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.UKFSlam.UKF_SLAM.Wc", "modulename": "algorithms.UKFSlam", "qualname": "UKF_SLAM.Wc", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.UKFSlam.UKF_SLAM.landmark_contestants", "modulename": "algorithms.UKFSlam", "qualname": "UKF_SLAM.landmark_contestants", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.UKFSlam.UKF_SLAM.sigma_points", "modulename": "algorithms.UKFSlam", "qualname": "UKF_SLAM.sigma_points", "kind": "function", "doc": "<p>Compute sigma points for calculating Unscented transform.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>x (np.ndarray):</strong>  mean</li>\n<li><strong>P (np.ndarray):</strong>  covariance</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">P</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "algorithms.UKFSlam.UKF_SLAM.f", "modulename": "algorithms.UKFSlam", "qualname": "UKF_SLAM.f", "kind": "function", "doc": "<p>State transition function.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>x (np.ndarray):</strong>  state</li>\n<li><strong>u (np.ndarray):</strong>  control input</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">u</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "algorithms.UKFSlam.UKF_SLAM.predict", "modulename": "algorithms.UKFSlam", "qualname": "UKF_SLAM.predict", "kind": "function", "doc": "<p>Predict step of Kalman filter.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>u (np.ndarray):</strong>  odometry</li>\n<li><strong>old_u (np.ndarray):</strong>  previous odometry</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">old_u</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "algorithms.UKFSlam.UKF_SLAM.update", "modulename": "algorithms.UKFSlam", "qualname": "UKF_SLAM.update", "kind": "function", "doc": "<p>Update step of Kalman Filter.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>z (np.ndarray):</strong>  measurement</li>\n<li><strong>h (function):</strong>  measurement function - returns in the same shape as z</li>\n<li><strong>R (np.ndarray):</strong>  measurement noise covariance</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">z</span>, </span><span class=\"param\"><span class=\"n\">h</span>, </span><span class=\"param\"><span class=\"n\">R</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "algorithms.UKFSlam.UKF_SLAM.data_association", "modulename": "algorithms.UKFSlam", "qualname": "UKF_SLAM.data_association", "kind": "function", "doc": "<p>Perform data association based on minimal distance between perceived data and landmarks.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>percep_data (np.ndarray):</strong>  perceived data</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>tuple: A tuple containing:\n      np.ndarray: indices of closest cones\n      np.ndarray: mask for perceived data</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">percep_data</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "algorithms.UKFSlam.UKF_SLAM.update_from_detections", "modulename": "algorithms.UKFSlam", "qualname": "UKF_SLAM.update_from_detections", "kind": "function", "doc": "<p>Updates the state of the SLAM system based on perception data and create map of landmarks.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>percep_data (numpy.ndarray):</strong>  A 2D array containing perception data.</li>\n<li><strong>time (float):</strong>  The current timestamp.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">percep_data</span>, </span><span class=\"param\"><span class=\"n\">time</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "algorithms.camera", "modulename": "algorithms.camera", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "algorithms.camera.softmax", "modulename": "algorithms.camera", "qualname": "softmax", "kind": "function", "doc": "<p>Compute the softmax of a given input array.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>x (numpy.ndarray):</strong>  Input array or vector for which to compute the softmax.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>numpy.ndarray: An array of the same shape as the input, where each\n  element represents the softmax probability of the corresponding input element.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "algorithms.camera.xywh2xyxy", "modulename": "algorithms.camera", "qualname": "xywh2xyxy", "kind": "function", "doc": "<p>Convert bounding box format from (x_center, y_center, width, height) to\n(x_min, y_min, x_max, y_max).</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>x (numpy.ndarray):</strong>  A 2D array where each row represents a bounding box\nin the format [x_center, y_center, width, height].</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>numpy.ndarray: A 2D array where each row represents a bounding box\n                 in the format [x_min, y_min, x_max, y_max].</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "algorithms.camera.xyxy2xywh", "modulename": "algorithms.camera", "qualname": "xyxy2xywh", "kind": "function", "doc": "<p>Convert bounding box coordinates from (x_min, y_min, x_max, y_max) format\nto (x_center, y_center, width, height) format.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>x (numpy.ndarray):</strong>  A 2D array where each row represents\na bounding box in the format [x_min, y_min, x_max, y_max].</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>numpy.ndarray: A 2D array  where each row represents\n                 a bounding box in the format [x_center, y_center, width, height].</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "algorithms.camera.OnnxCamera", "modulename": "algorithms.camera", "qualname": "OnnxCamera", "kind": "class", "doc": "<p>A class for performing object detection  using an ONNX model and coordinate transformation.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>cam_K (numpy.ndarray):</strong>  Inverse of the camera intrinsic matrix.</li>\n<li><strong>depth_K (numpy.ndarray):</strong>  Inverse of the depth camera intrinsic matrix.</li>\n<li><strong>cam_to_depth (numpy.ndarray):</strong>  Transformation matrix from camera to depth coordinates.</li>\n<li><strong>verbose (bool):</strong>  Flag to enable verbose logging.</li>\n<li><strong>conf_thresh (float):</strong>  Confidence threshold for filtering detection results.</li>\n<li><strong>model (onnxruntime.InferenceSession):</strong>  ONNX model inference session.</li>\n<li><strong>input_name (str):</strong>  Name of the input tensor for the ONNX model.</li>\n<li><strong>output_name (str):</strong>  Name of the output tensor for the ONNX model.</li>\n<li><strong>input_shape (list):</strong>  Shape of the input tensor for the ONNX model.</li>\n<li><strong>R_y (numpy.ndarray):</strong>  Rotation matrix for adjusting camera angle.</li>\n<li><strong>class_map (dict):</strong>  Mapping of class IDs to custom class indices.</li>\n</ul>\n\n<h6 id=\"methods\">Methods:</h6>\n\n<blockquote>\n  <p>__init__(model_path, cam_K, depth_K, conf_thresh=0.25, verbose=False):\n      Initializes the OnnxCamera object with the given parameters.\n  detect(image):\n      Performs object detection on the input image using the ONNX model.\n  get_detections(image, depth_image):\n      Detects objects in the input image, calculates their world coordinates, and visualizes results.</p>\n</blockquote>\n"}, {"fullname": "algorithms.camera.OnnxCamera.__init__", "modulename": "algorithms.camera", "qualname": "OnnxCamera.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">model_path</span>, </span><span class=\"param\"><span class=\"n\">cam_K</span>, </span><span class=\"param\"><span class=\"n\">depth_K</span>, </span><span class=\"param\"><span class=\"n\">conf_thresh</span><span class=\"o\">=</span><span class=\"mf\">0.25</span>, </span><span class=\"param\"><span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span>)</span>"}, {"fullname": "algorithms.camera.OnnxCamera.cam_K", "modulename": "algorithms.camera", "qualname": "OnnxCamera.cam_K", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.camera.OnnxCamera.depth_K", "modulename": "algorithms.camera", "qualname": "OnnxCamera.depth_K", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.camera.OnnxCamera.cam_to_depth", "modulename": "algorithms.camera", "qualname": "OnnxCamera.cam_to_depth", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.camera.OnnxCamera.verbose", "modulename": "algorithms.camera", "qualname": "OnnxCamera.verbose", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.camera.OnnxCamera.conf_thresh", "modulename": "algorithms.camera", "qualname": "OnnxCamera.conf_thresh", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.camera.OnnxCamera.model", "modulename": "algorithms.camera", "qualname": "OnnxCamera.model", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.camera.OnnxCamera.input_name", "modulename": "algorithms.camera", "qualname": "OnnxCamera.input_name", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.camera.OnnxCamera.output_name", "modulename": "algorithms.camera", "qualname": "OnnxCamera.output_name", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.camera.OnnxCamera.input_shape", "modulename": "algorithms.camera", "qualname": "OnnxCamera.input_shape", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.camera.OnnxCamera.class_map", "modulename": "algorithms.camera", "qualname": "OnnxCamera.class_map", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.camera.OnnxCamera.detect", "modulename": "algorithms.camera", "qualname": "OnnxCamera.detect", "kind": "function", "doc": "<p>Perform object detection on the given image.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>image (numpy.ndarray):</strong>  The input image in BGR format.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>numpy.ndarray: A 2D array where each row represents a detected object with the following columns:\n      - [0:4]: Bounding box coordinates in the format [x_min, y_min, x_max, y_max].\n      - [4]: Confidence score of the detection.\n      - [5]: Class label of the detected object.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">image</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "algorithms.camera.OnnxCamera.get_detections", "modulename": "algorithms.camera", "qualname": "OnnxCamera.get_detections", "kind": "function", "doc": "<p>Processes an image and its corresponding depth image to detect objects and\ncalculate their world coordinates.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>image (numpy.ndarray):</strong>  The BGR image to process.</li>\n<li><strong>depth_image (numpy.ndarray):</strong>  The depth image corresponding to the RGB image.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>numpy.ndarray: A 2D array where each row represents the world coordinates and class.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">image</span>, </span><span class=\"param\"><span class=\"n\">depth_image</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "algorithms.geometry", "modulename": "algorithms.geometry", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "algorithms.geometry.global_to_local", "modulename": "algorithms.geometry", "qualname": "global_to_local", "kind": "function", "doc": "<p>Convert points from global to local coordinates.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  Points to be converted</li>\n<li><strong>pose (np.ndarray):</strong>  Position of the car in global coordinates (x,y,yaw)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: Converted points</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">points</span>, </span><span class=\"param\"><span class=\"n\">pose</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "algorithms.geometry.local_to_global", "modulename": "algorithms.geometry", "qualname": "local_to_global", "kind": "function", "doc": "<p>Convert points from local to global coordinates.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  Points to be converted</li>\n<li><strong>pose (np.ndarray):</strong>  Position of the car in global coordinates (x,y,yaw)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: Converted points</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">points</span>, </span><span class=\"param\"><span class=\"n\">pose</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "algorithms.geometry.rotate_points", "modulename": "algorithms.geometry", "qualname": "rotate_points", "kind": "function", "doc": "<p>Rotate points around the origin</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  Points to be rotated</li>\n<li><strong>angle (float):</strong>  Angle in radians</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: Rotated points</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">points</span>, </span><span class=\"param\"><span class=\"n\">angle</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "algorithms.odometry", "modulename": "algorithms.odometry", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "algorithms.odometry.Odometry", "modulename": "algorithms.odometry", "qualname": "Odometry", "kind": "class", "doc": "<p>A class to manage and track the odometry of the robot.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>turtle:</strong>  Instance of the turtle_bot class.</li>\n<li><strong>last_odometry:</strong>  The last recorded odometry data of the turtle robot.</li>\n</ul>\n\n<h6 id=\"methods\">Methods:</h6>\n\n<blockquote>\n  <p>__init__(turtle):\n      Initializes the Odometry object with the given turtle robot and stores its initial odometry data.\n  update_and_get_delta():\n      Updates the stored odometry data and returns the previous and current odometry values as a tuple.</p>\n</blockquote>\n"}, {"fullname": "algorithms.odometry.Odometry.__init__", "modulename": "algorithms.odometry", "qualname": "Odometry.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">turtle</span></span>)</span>"}, {"fullname": "algorithms.odometry.Odometry.turtle", "modulename": "algorithms.odometry", "qualname": "Odometry.turtle", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.odometry.Odometry.last_odometry", "modulename": "algorithms.odometry", "qualname": "Odometry.last_odometry", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.odometry.Odometry.update_and_get_delta", "modulename": "algorithms.odometry", "qualname": "Odometry.update_and_get_delta", "kind": "function", "doc": "<p>Updates the stored odometry data and calculates the delta between the\nprevious and current odometry readings.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>tuple: A tuple containing two elements:\n      - odo_old: The previous odometry reading.\n      - odo_new: The current odometry reading.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "algorithms.velocity_control", "modulename": "algorithms.velocity_control", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "algorithms.velocity_control.VelocityControl", "modulename": "algorithms.velocity_control", "qualname": "VelocityControl", "kind": "class", "doc": "<p>A class to control the velocity of the robot, ensuring smooth acceleration\nand deceleration while adhering to specified constraints on speed and angular velocity.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>turtle:</strong>  Instance of the turtle_bot class.</li>\n<li><strong>velocity (float):</strong>  The current linear velocity of the turtle.</li>\n<li><strong>max_acc (float):</strong>  The maximum linear acceleration (m/s^2).</li>\n<li><strong>max_ang_acc (float):</strong>  The maximum angular acceleration (rad/s^2).</li>\n<li><strong>max_speed (float):</strong>  The maximum linear speed (m/s).</li>\n<li><strong>max_ang_speed (float):</strong>  The maximum angular speed (rad/s).</li>\n<li><strong>last_cmd (tuple):</strong>  The last commanded velocity as a tuple (linear, angular).</li>\n<li><strong>ang_p (float):</strong>  The proportional gain for angular velocity control.</li>\n</ul>\n\n<h6 id=\"methods\">Methods:</h6>\n\n<blockquote>\n  <p>cmd_velocity(position, target_position, dt):\n      Computes the linear and angular velocity commands to move the turtle\n      towards a target position while respecting acceleration and speed limits.</p>\n</blockquote>\n"}, {"fullname": "algorithms.velocity_control.VelocityControl.velocity", "modulename": "algorithms.velocity_control", "qualname": "VelocityControl.velocity", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.velocity_control.VelocityControl.max_acc", "modulename": "algorithms.velocity_control", "qualname": "VelocityControl.max_acc", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.velocity_control.VelocityControl.max_speed", "modulename": "algorithms.velocity_control", "qualname": "VelocityControl.max_speed", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.velocity_control.VelocityControl.max_ang_speed", "modulename": "algorithms.velocity_control", "qualname": "VelocityControl.max_ang_speed", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.velocity_control.VelocityControl.last_cmd", "modulename": "algorithms.velocity_control", "qualname": "VelocityControl.last_cmd", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.velocity_control.VelocityControl.ang_p", "modulename": "algorithms.velocity_control", "qualname": "VelocityControl.ang_p", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.velocity_control.VelocityControl.cmd_velocity", "modulename": "algorithms.velocity_control", "qualname": "VelocityControl.cmd_velocity", "kind": "function", "doc": "<p>Calculate the linear and angular velocity required to move towards a target position.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>position (numpy.ndarray):</strong>  The current position and orientation of the object\nin the global frame.</li>\n<li><strong>target_position (numpy.ndarray):</strong>  The target position in the global frame.</li>\n<li><strong>dt (float):</strong>  The time step for velocity calculation.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>tuple: A tuple containing:\n      - velocity (float): The linear velocity to move towards the target position.\n      - ang_velocity (float): The angular velocity to rotate towards the target position.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">position</span>, </span><span class=\"param\"><span class=\"n\">target_position</span>, </span><span class=\"param\"><span class=\"n\">dt</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "configs", "modulename": "configs", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "configs.alg_config", "modulename": "configs.alg_config", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "configs.alg_config.slam_config", "modulename": "configs.alg_config", "qualname": "slam_config", "kind": "variable", "doc": "<p></p>\n", "default_value": "{&#x27;pairing_distance&#x27;: 0.6, &#x27;detection_var&#x27;: 0.2, &#x27;position_var&#x27;: 0.02, &#x27;rotation_var&#x27;: 0.001, &#x27;min_occurences&#x27;: 2, &#x27;detection_timeout&#x27;: 1}"}, {"fullname": "configs.alg_config.PlanningParm", "modulename": "configs.alg_config", "qualname": "PlanningParm", "kind": "class", "doc": "<p>PlanningParm is a configuration class.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>CLEARANCE (float):</strong>  Minimum clearance distance required around obstacles.</li>\n<li><strong>SHOOT_SCALING (float):</strong>  Scaling factor for shooting calculations.</li>\n<li><strong>SHOOT_STEPBACK (float):</strong>  Distance to step back before kicking the ball.</li>\n<li><strong>BALL_PROXIMITY (float):</strong>  Proximity threshold to the ball.</li>\n<li><strong>HADING_CHECK (float):</strong>  Heading check threshold in radians.</li>\n<li><strong>ROBOT_TURN_RADIUS (float):</strong>  Turning radius of the robot.</li>\n<li><strong>GOAL_POX (float):</strong>  Proximity threshold to the goal position.</li>\n<li><strong>SHOOT_ALIGNMENT (float):</strong>  Alignment threshold for shooting.</li>\n<li><strong>GOAL_CHECK (float):</strong>  Position of checks points for goal. Behind and in front of the goal line.</li>\n<li><strong>ROBOT_DIST_MIN (float):</strong>  How close to the goal line, can the robot get to.</li>\n</ul>\n"}, {"fullname": "configs.alg_config.PlanningParm.CLEARANCE", "modulename": "configs.alg_config", "qualname": "PlanningParm.CLEARANCE", "kind": "variable", "doc": "<p></p>\n", "default_value": "0.5"}, {"fullname": "configs.alg_config.PlanningParm.SHOOT_SCALING", "modulename": "configs.alg_config", "qualname": "PlanningParm.SHOOT_SCALING", "kind": "variable", "doc": "<p></p>\n", "default_value": "2"}, {"fullname": "configs.alg_config.PlanningParm.SHOOT_STEPBACK", "modulename": "configs.alg_config", "qualname": "PlanningParm.SHOOT_STEPBACK", "kind": "variable", "doc": "<p></p>\n", "default_value": "0.8"}, {"fullname": "configs.alg_config.PlanningParm.BALL_PROXIMITY", "modulename": "configs.alg_config", "qualname": "PlanningParm.BALL_PROXIMITY", "kind": "variable", "doc": "<p></p>\n", "default_value": "0.2"}, {"fullname": "configs.alg_config.PlanningParm.HADING_CHECK", "modulename": "configs.alg_config", "qualname": "PlanningParm.HADING_CHECK", "kind": "variable", "doc": "<p></p>\n", "default_value": "0.1746"}, {"fullname": "configs.alg_config.PlanningParm.ROBOT_TURN_RADIUS", "modulename": "configs.alg_config", "qualname": "PlanningParm.ROBOT_TURN_RADIUS", "kind": "variable", "doc": "<p></p>\n", "default_value": "0.3"}, {"fullname": "configs.alg_config.PlanningParm.GOAL_POX", "modulename": "configs.alg_config", "qualname": "PlanningParm.GOAL_POX", "kind": "variable", "doc": "<p></p>\n", "default_value": "0.7"}, {"fullname": "configs.alg_config.PlanningParm.SHOOT_ALIGNMENT", "modulename": "configs.alg_config", "qualname": "PlanningParm.SHOOT_ALIGNMENT", "kind": "variable", "doc": "<p></p>\n", "default_value": "0.1"}, {"fullname": "configs.alg_config.PlanningParm.GOAL_CHECK", "modulename": "configs.alg_config", "qualname": "PlanningParm.GOAL_CHECK", "kind": "variable", "doc": "<p></p>\n", "default_value": "0.1"}, {"fullname": "configs.alg_config.PlanningParm.ROBOT_DIST_MIN", "modulename": "configs.alg_config", "qualname": "PlanningParm.ROBOT_DIST_MIN", "kind": "variable", "doc": "<p></p>\n", "default_value": "0.48"}, {"fullname": "configs.alg_config.vision_config", "modulename": "configs.alg_config", "qualname": "vision_config", "kind": "variable", "doc": "<p></p>\n", "default_value": "{&#x27;show&#x27;: False, &#x27;cls_to_col&#x27;: {&lt;DataClasses.GREEN: 0&gt;: (0, 255, 0), &lt;DataClasses.RED: 1&gt;: (0, 0, 255), &lt;DataClasses.BLUE: 2&gt;: (255, 0, 0), &lt;DataClasses.BALL: 3&gt;: (0, 255, 255)}, &#x27;class_map&#x27;: {0: &lt;DataClasses.BALL: 3&gt;, 1: &lt;DataClasses.BALL: 3&gt;, 2: &lt;DataClasses.BLUE: 2&gt;, 3: &lt;DataClasses.GREEN: 0&gt;, 4: &lt;DataClasses.RED: 1&gt;}}"}, {"fullname": "configs.alg_config.velocity_control_config", "modulename": "configs.alg_config", "qualname": "velocity_control_config", "kind": "variable", "doc": "<p></p>\n", "default_value": "{&#x27;max_acc&#x27;: 0.8, &#x27;max_speed&#x27;: 0.8, &#x27;max_ang_speed&#x27;: 0.8, &#x27;ang_p&#x27;: 1.5}"}, {"fullname": "configs.value_enums", "modulename": "configs.value_enums", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "configs.value_enums.DataClasses", "modulename": "configs.value_enums", "qualname": "DataClasses", "kind": "class", "doc": "<p>Enum for data classes</p>\n", "bases": "enum.IntEnum"}, {"fullname": "configs.value_enums.DataClasses.GREEN", "modulename": "configs.value_enums", "qualname": "DataClasses.GREEN", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;DataClasses.GREEN: 0&gt;"}, {"fullname": "configs.value_enums.DataClasses.RED", "modulename": "configs.value_enums", "qualname": "DataClasses.RED", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;DataClasses.RED: 1&gt;"}, {"fullname": "configs.value_enums.DataClasses.BLUE", "modulename": "configs.value_enums", "qualname": "DataClasses.BLUE", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;DataClasses.BLUE: 2&gt;"}, {"fullname": "configs.value_enums.DataClasses.BALL", "modulename": "configs.value_enums", "qualname": "DataClasses.BALL", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;DataClasses.BALL: 3&gt;"}, {"fullname": "configs.value_enums.ErrorCodes", "modulename": "configs.value_enums", "qualname": "ErrorCodes", "kind": "class", "doc": "<p>Enum for data classed.</p>\n", "bases": "enum.IntEnum"}, {"fullname": "configs.value_enums.ErrorCodes.OK_ERR", "modulename": "configs.value_enums", "qualname": "ErrorCodes.OK_ERR", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ErrorCodes.OK_ERR: 0&gt;"}, {"fullname": "configs.value_enums.ErrorCodes.MORE_BLUE_ERR", "modulename": "configs.value_enums", "qualname": "ErrorCodes.MORE_BLUE_ERR", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ErrorCodes.MORE_BLUE_ERR: 1&gt;"}, {"fullname": "configs.value_enums.ErrorCodes.NO_BALL_ERR", "modulename": "configs.value_enums", "qualname": "ErrorCodes.NO_BALL_ERR", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ErrorCodes.NO_BALL_ERR: 2&gt;"}, {"fullname": "configs.value_enums.ErrorCodes.BALL_STUCK_ERR", "modulename": "configs.value_enums", "qualname": "ErrorCodes.BALL_STUCK_ERR", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ErrorCodes.BALL_STUCK_ERR: 3&gt;"}, {"fullname": "configs.value_enums.ErrorCodes.NO_SHOOT_ERR", "modulename": "configs.value_enums", "qualname": "ErrorCodes.NO_SHOOT_ERR", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ErrorCodes.NO_SHOOT_ERR: 4&gt;"}, {"fullname": "configs.value_enums.ErrorCodes.NO_ROBOT_ERR", "modulename": "configs.value_enums", "qualname": "ErrorCodes.NO_ROBOT_ERR", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ErrorCodes.NO_ROBOT_ERR: 5&gt;"}, {"fullname": "configs.value_enums.ErrorCodes.ZERO_BLUE_ERR", "modulename": "configs.value_enums", "qualname": "ErrorCodes.ZERO_BLUE_ERR", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ErrorCodes.ZERO_BLUE_ERR: 6&gt;"}, {"fullname": "configs.value_enums.ErrorCodes.IS_GOAL_ERR", "modulename": "configs.value_enums", "qualname": "ErrorCodes.IS_GOAL_ERR", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ErrorCodes.IS_GOAL_ERR: 7&gt;"}, {"fullname": "SimMain", "modulename": "SimMain", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "SimMain.Simulation", "modulename": "SimMain", "qualname": "Simulation", "kind": "class", "doc": "<p>Simulation class for a 2D TurtleBot football simulator.\nThis class handles the initialization, object generation, collision detection,\nmovement, and visualization of the simulation. It uses pygame for rendering\nand numpy for mathematical operations.</p>\n\n<h6 id=\"methods\">Methods:</h6>\n\n<blockquote>\n  <p>__init__():\n      Initializes the simulation, pygame, and sets up the environment.\n  generate_point_in_ring(a, b):\n      Generates a random point within a ring defined by radii <code>a</code> and <code>b</code>.\n  check_collisions(pos, radius, skip=[]):\n      Checks for collisions of a circular object with other objects in the simulation.\n  generate_gate():\n      Generates a pair of blue pillars representing the gate.\n  generate_ball():\n      Generates a ball according to the simulation rules.\n  generate_tube(count):\n      Generates a specified number of green tubes at random positions.\n  generate_turtle():\n      Generates a turtle robot at a random position.\n  draw_object(object):\n      Draws a given object on the screen.\n  redraw_everything():\n      Redraws the playground, all objects, and paths.\n  redraw_paths():\n      Redraws the paths for the robot, ball, and shooting trajectory.\n  maual_movement():\n      Handles manual movement of the turtle robot using keyboard inputs.\n  sim_update():\n      Updates the simulation, including ball movement and collision handling.\n  get_positions():\n      Retrieves the positions and types of all objects in the simulation.\n  is_in_fov(objects, robot_pos, robot_angle):\n      Checks if objects are within the field of view of the robot.\n  planing_visual():\n      Runs the planning algorithm and visualizes the generated paths.\n  load_path(path, color):\n      Loads a path and visualizes it with the specified color.\n  main():\n      Main loop of the simulation. Handles events, updates, and rendering.</p>\n</blockquote>\n"}, {"fullname": "SimMain.Simulation.screen", "modulename": "SimMain", "qualname": "Simulation.screen", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "SimMain.Simulation.objects", "modulename": "SimMain", "qualname": "Simulation.objects", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "SimMain.Simulation.play_ground", "modulename": "SimMain", "qualname": "Simulation.play_ground", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "SimMain.Simulation.path", "modulename": "SimMain", "qualname": "Simulation.path", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "SimMain.Simulation.path_robot", "modulename": "SimMain", "qualname": "Simulation.path_robot", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "SimMain.Simulation.path_ball", "modulename": "SimMain", "qualname": "Simulation.path_ball", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "SimMain.Simulation.path_shoot", "modulename": "SimMain", "qualname": "Simulation.path_shoot", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "SimMain.Simulation.clock", "modulename": "SimMain", "qualname": "Simulation.clock", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "SimMain.Simulation.generate_point_in_ring", "modulename": "SimMain", "qualname": "Simulation.generate_point_in_ring", "kind": "function", "doc": "<p>Generates a random point within a ring defined by two radii, <code>a</code> and <code>b</code>.</p>\n\n<p>The ring is defined as the area between two concentric circles with radii <code>a</code> and <code>b</code>.\nThe function randomly selects a value within the range [a, b] or [-b, -a].</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>a (float):</strong>  The inner radius of the ring.</li>\n<li><strong>b (float):</strong>  The outer radius of the ring.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>float: A randomly generated point within the specified ring.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">b</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "SimMain.Simulation.check_collisions", "modulename": "SimMain", "qualname": "Simulation.check_collisions", "kind": "function", "doc": "<p>Checks for collisions between a given position and radius against all objects in the simulation.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>pos (tuple):</strong>  The position to check for collisions, typically a (x, y) coordinate.</li>\n<li><strong>radius (float):</strong>  The radius around the position to check for collisions.</li>\n<li><strong>skip (list, optional):</strong>  A list of object types to skip during the collision check. Defaults to an empty list.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if a collision is detected, False otherwise.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">pos</span>, </span><span class=\"param\"><span class=\"n\">radius</span>, </span><span class=\"param\"><span class=\"n\">skip</span><span class=\"o\">=</span><span class=\"p\">[]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "SimMain.Simulation.generate_gate", "modulename": "SimMain", "qualname": "Simulation.generate_gate", "kind": "function", "doc": "<p>Generates a gate consisting of two tubes placed horizontally on the simulation field.\nThe method creates two tubes of the same color (blue) and places them at specific\ncoordinates along the Y-axis defined by <code>SimParm.GATE_Y_START</code>. The X-coordinates\nof the tubes are determined randomly within a specified range, ensuring the gate\nwidth does not exceed the maximum allowed value.\nThe generated tubes are stored in the <code>self.objects</code> dictionary under the key\ncorresponding to their color.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "SimMain.Simulation.generate_ball", "modulename": "SimMain", "qualname": "Simulation.generate_ball", "kind": "function", "doc": "<p>Generates a new ball object and places it in the simulation.\nThe ball's position is determined based on the center of the blue gate and\na random offset within a specified range. The x-coordinate is calculated\nby adding a random offset to the center of the blue gate, while the\ny-coordinate is determined by adding a random value within a specified\nrange to the y-coordinate of the first blue object.\nThe generated ball is then added to the simulation's objects dictionary\nunder the BALL key.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>gate_center (float):</strong>  The x-coordinate of the center of the blue gate.</li>\n<li><strong>x (float):</strong>  The x-coordinate of the generated ball.</li>\n<li><strong>y (float):</strong>  The y-coordinate of the generated ball.</li>\n</ul>\n\n<h6 id=\"raises\">Raises:</h6>\n\n<ul>\n<li><strong>KeyError:</strong>  If the required keys (BLUE or BALL) are not present in the\nobjects dictionary.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "SimMain.Simulation.generate_tube", "modulename": "SimMain", "qualname": "Simulation.generate_tube", "kind": "function", "doc": "<p>Generates a specified number of tube objects and places them in the simulation environment.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>count (int):</strong>  The number of tube objects to generate.</li>\n</ul>\n\n<p>The method randomly generates positions for the tubes within the simulation boundaries,\nensuring that they do not collide with existing objects. If a valid position is found,\nthe tube is added to the list of objects in the simulation.</p>\n\n<h6 id=\"notes\">Notes:</h6>\n\n<blockquote>\n  <ul>\n  <li>The position is generated within the range defined by <code>SimParm.SIDE_REAL</code> for both\n  x and y coordinates, with additional constraints for the y-coordinate to avoid\n  overlap with the gate area.</li>\n  <li>Collision checks are performed using the <code>check_collisions</code> method with a radius\n  of 0.5.</li>\n  <li>Tubes are appended to the <code>self.objects[DataClasses.GREEN]</code> list.</li>\n  </ul>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">count</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "SimMain.Simulation.generate_turtle", "modulename": "SimMain", "qualname": "Simulation.generate_turtle", "kind": "function", "doc": "<p>Generates a new turtle object and places it in the simulation environment.\nThe method randomly generates a position for the turtle within the simulation\nboundaries, ensuring that it does not collide with existing objects and maintains\na minimum distance from other objects. Once a valid position is found, the turtle\nis created and added to the simulation's objects dictionary.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "SimMain.Simulation.draw_object", "modulename": "SimMain", "qualname": "Simulation.draw_object", "kind": "function", "doc": "<p>Draws the given object by iterating through its subcomponents and calling their draw method.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>object (iterable):</strong>  An iterable containing subcomponents, each of which must have a <code>draw</code> method.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">sefl</span>, </span><span class=\"param\"><span class=\"nb\">object</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "SimMain.Simulation.redraw_everything", "modulename": "SimMain", "qualname": "Simulation.redraw_everything", "kind": "function", "doc": "<p>Redraws all elements in the simulation environment.\nThis method updates the visual representation of the playground,\nall objects, and paths in the simulation. It performs the following steps:</p>\n\n<ol>\n<li>Draws the playground.</li>\n<li>Iterates through all object types and draws each object.</li>\n<li>Redraws the paths in the simulation.</li>\n</ol>\n\n<h6 id=\"note\">Note:</h6>\n\n<blockquote>\n  <p>Ensure that the <code>self.play_ground</code>, <code>self.objects</code>, and <code>self.redraw_paths</code>\n  are properly initialized before calling this method.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "SimMain.Simulation.redraw_paths", "modulename": "SimMain", "qualname": "Simulation.redraw_paths", "kind": "function", "doc": "<p>Redraws the paths for the robot, ball, and shoot if they exist.\nThis method checks if the paths for the robot, ball, and shoot are not None.\nIf a path exists, it calls the <code>draw</code> method on the respective path object\nto redraw it on the screen or canvas.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "SimMain.Simulation.maual_movement", "modulename": "SimMain", "qualname": "Simulation.maual_movement", "kind": "function", "doc": "<p>Handles manual movement of the turtle object based on keyboard input.\nThis method listens for specific key presses to control the movement\nand rotation of the turtle object in the simulation.</p>\n\n<h6 id=\"key-bindings\">Key Bindings:</h6>\n\n<blockquote>\n  <ul>\n  <li>W: Move the turtle forward.</li>\n  <li>S: Move the turtle backward.</li>\n  <li>A: Rotate the turtle counter-clockwise (turn left).</li>\n  <li>D: Rotate the turtle clockwise (turn right).</li>\n  </ul>\n</blockquote>\n\n<h6 id=\"movement-details\">Movement Details:</h6>\n\n<blockquote>\n  <ul>\n  <li>Forward and backward movement is controlled by the <code>move</code> method\n  of the turtle object, with the <code>forward</code> parameter determining\n  the direction.</li>\n  <li>Rotation is controlled by the <code>move</code> method, with the <code>clockwise</code>\n  parameter determining the direction of rotation.</li>\n  </ul>\n</blockquote>\n\n<h6 id=\"note\">Note:</h6>\n\n<blockquote>\n  <p>This method requires the <code>pygame</code> library for detecting key presses\n  and assumes that the <code>self.objects</code> dictionary contains a <code>TURTLE</code>\n  key mapped to a list of turtle objects.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "SimMain.Simulation.sim_update", "modulename": "SimMain", "qualname": "Simulation.sim_update", "kind": "function", "doc": "<p>Updates the simulation state by handling the movement of the ball and its interactions\nwith other objects in the simulation.\nThe method performs the following tasks:</p>\n\n<ol>\n<li>Updates the ball's movement by invoking its <code>movement</code> method.</li>\n<li>Checks for a collision between the ball and the turtle. If a collision occurs:\n<ul>\n<li>Adjusts the ball's velocity based on the turtle's orientation and velocity.</li>\n</ul></li>\n<li>Checks for collisions between the ball and other objects (excluding the ball and turtle).\n<ul>\n<li>If a collision is detected, the ball's velocity is set to zero.\nNote:</li>\n</ul></li>\n</ol>\n\n<ul>\n<li>The ball's velocity is updated using the <code>set_velocity</code> method.</li>\n<li>Collisions are detected using the <code>was_collision</code> and <code>check_collisions</code> methods.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "SimMain.Simulation.get_positions", "modulename": "SimMain", "qualname": "Simulation.get_positions", "kind": "function", "doc": "<p>Retrieves the positions and types of objects in the simulation, excluding objects of type TURTLE.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>numpy.ndarray: A 2D array where each row represents an object. Each row contains:\n      - The x-coordinate of the object's position adjusted by the simulation offset.\n      - The y-coordinate of the object's position adjusted by the simulation offset.\n      - The type of the object.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "SimMain.Simulation.is_in_fov", "modulename": "SimMain", "qualname": "Simulation.is_in_fov", "kind": "function", "doc": "<p>Determines which objects are within the field of view (FOV) of a robot.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>objects (numpy.ndarray):</strong>  A 2D array of shape (N, M) where each row represents an object.\nThe first two columns (objects[:, :2]) represent the (x, y) positions of the objects.</li>\n<li><strong>robot_pos (numpy.ndarray):</strong>  A 1D array of shape (2,) representing the (x, y) position of the robot.</li>\n<li><strong>robot_angle (float):</strong>  The orientation of the robot in radians.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>numpy.ndarray: A subset of the input <code>objects</code> array containing only the objects that are within the robot's FOV.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">objects</span>, </span><span class=\"param\"><span class=\"n\">robot_pos</span>, </span><span class=\"param\"><span class=\"n\">robot_angle</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "SimMain.Simulation.planing_visual", "modulename": "SimMain", "qualname": "Simulation.planing_visual", "kind": "function", "doc": "<p>Visualizes the planning paths for the robot, including its movement path,\nshooting path, and ball path, based on the robot's position and objects\nwithin its field of view (FOV).\nThe method performs the following steps:</p>\n\n<ol>\n<li>Calculates the robot's position relative to a simulation offset.</li>\n<li>Identifies objects within the robot's field of view.</li>\n<li>Creates paths for the robot, shooting, and ball based on the identified objects.</li>\n<li>Loads and visualizes the paths if they are successfully created.</li>\n</ol>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool:\n      - True if the robot path is not created (indicating no further visualization).\n      - False if the robot path is successfully created and visualized.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "SimMain.Simulation.load_path", "modulename": "SimMain", "qualname": "Simulation.load_path", "kind": "function", "doc": "<p>Loads a path and creates an ExitPath object with the specified color.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>path (list of numpy.ndarray):</strong>  A list of points representing the path.\nEach point is expected to be a numpy array.</li>\n<li><strong>color (str):</strong>  The color associated with the ExitPath object.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>ExitPath: An ExitPath object with the given points and color.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">path</span>, </span><span class=\"param\"><span class=\"n\">color</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "SimMain.Simulation.main", "modulename": "SimMain", "qualname": "Simulation.main", "kind": "function", "doc": "<p>The main function that runs the simulation loop.\nThis function initializes the simulation by generating various objects such as gates, balls, tubes,\nand turtles. It then enters a loop where it processes events, updates the simulation, checks for\ncompletion conditions, and redraws the simulation state. The loop continues running until the user\nquits the application or the mission is accomplished.\nKey functionalities:</p>\n\n<ul>\n<li>Initializes simulation objects.</li>\n<li>Handles user input and events.</li>\n<li>Updates the simulation state.</li>\n<li>Checks for mission completion.</li>\n<li>Redraws the simulation visuals.</li>\n<li>Limits the frame rate to 100 frames per second.\nThe simulation ends when the user closes the application, presses the ESCAPE key, or the mission\nis successfully completed.\nNote:</li>\n<li>This function requires the <code>pygame</code> library to be properly initialized before execution.</li>\n<li>The <code>sim_update</code>, <code>planing_visual</code>, <code>redraw_everything</code>, and <code>maual_movement</code> methods are assumed\nto be defined elsewhere in the class.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "Sim", "modulename": "Sim", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "Sim.SimConfig", "modulename": "Sim.SimConfig", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "Sim.SimConfig.SimParm", "modulename": "Sim.SimConfig", "qualname": "SimParm", "kind": "class", "doc": "<p>SimParm is a configuration class that defines various parameters and constants\nused in the simulation. These parameters include visual settings, playground\ndimensions, simulator settings, setup configurations, and object properties.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>WHITE (tuple):</strong>  RGB color for white.</li>\n<li><strong>BLACK (tuple):</strong>  RGB color for black.</li>\n<li><strong>RED (tuple):</strong>  RGB color for red.</li>\n<li><strong>YELLOW (tuple):</strong>  RGB color for yellow.</li>\n<li><strong>GREEN (tuple):</strong>  RGB color for green.</li>\n<li><strong>BLUE (tuple):</strong>  RGB color for blue.</li>\n<li><strong>WIDTH (int):</strong>  Width of the simulation playground in pixels.</li>\n<li><strong>HEIGHT (int):</strong>  Height of the simulation playground in pixels.</li>\n<li><strong>SIDE_REAL (float):</strong>  Real-world side length of the playground in meters.</li>\n<li><strong>SIM_OFFSET (float):</strong>  Offset for simulation scaling.</li>\n<li># Simulator parameters</li>\n<li><strong>SIM_FPS (int):</strong>  Frames per second for the simulation.</li>\n<li><strong>SIM_FRICTION (float):</strong>  Friction coefficient in the simulation.</li>\n<li># Sim setup parameters</li>\n<li><strong>GATE_Y_START (float):</strong>  Starting Y-coordinate for the gate in meters.</li>\n<li><strong>MAX_GATE_WIDTH (float):</strong>  Maximum width of the gate in meters.</li>\n<li><strong>BALL_GATE_CENTER (float):</strong>  Center position of the ball gate in meters.</li>\n<li><strong>MIN_DIS_START (float):</strong>  Minimum starting distance for objects in meters.</li>\n<li><strong>MAX_DIS_START (float):</strong>  Maximum starting distance for objects in meters.</li>\n<li><strong>CAMERA_FOV (float):</strong>  Field of view of the camera in radians.</li>\n<li><strong>FOV_LINE_LENGTH (int):</strong>  Length of the field of view lines in pixels.</li>\n<li># Objects parameters</li>\n<li><strong>TUBE_RADIUS (float):</strong>  Radius of the tube in meters.</li>\n<li><strong>TURTLE_RADIUS (float):</strong>  Radius of the turtle in meters.</li>\n<li><strong>BALL_RADIUS (float):</strong>  Radius of the ball in meters.</li>\n</ul>\n"}, {"fullname": "Sim.SimConfig.SimParm.WHITE", "modulename": "Sim.SimConfig", "qualname": "SimParm.WHITE", "kind": "variable", "doc": "<p></p>\n", "default_value": "(255, 255, 255)"}, {"fullname": "Sim.SimConfig.SimParm.BLACK", "modulename": "Sim.SimConfig", "qualname": "SimParm.BLACK", "kind": "variable", "doc": "<p></p>\n", "default_value": "(0, 0, 0)"}, {"fullname": "Sim.SimConfig.SimParm.RED", "modulename": "Sim.SimConfig", "qualname": "SimParm.RED", "kind": "variable", "doc": "<p></p>\n", "default_value": "(255, 0, 0)"}, {"fullname": "Sim.SimConfig.SimParm.YELLOW", "modulename": "Sim.SimConfig", "qualname": "SimParm.YELLOW", "kind": "variable", "doc": "<p></p>\n", "default_value": "(255, 255, 0)"}, {"fullname": "Sim.SimConfig.SimParm.GREEN", "modulename": "Sim.SimConfig", "qualname": "SimParm.GREEN", "kind": "variable", "doc": "<p></p>\n", "default_value": "(0, 255, 0)"}, {"fullname": "Sim.SimConfig.SimParm.BLUE", "modulename": "Sim.SimConfig", "qualname": "SimParm.BLUE", "kind": "variable", "doc": "<p></p>\n", "default_value": "(0, 0, 255)"}, {"fullname": "Sim.SimConfig.SimParm.WIDTH", "modulename": "Sim.SimConfig", "qualname": "SimParm.WIDTH", "kind": "variable", "doc": "<p></p>\n", "default_value": "1000"}, {"fullname": "Sim.SimConfig.SimParm.HEIGHT", "modulename": "Sim.SimConfig", "qualname": "SimParm.HEIGHT", "kind": "variable", "doc": "<p></p>\n", "default_value": "1000"}, {"fullname": "Sim.SimConfig.SimParm.SIDE_REAL", "modulename": "Sim.SimConfig", "qualname": "SimParm.SIDE_REAL", "kind": "variable", "doc": "<p></p>\n", "default_value": "5"}, {"fullname": "Sim.SimConfig.SimParm.SIM_OFFSET", "modulename": "Sim.SimConfig", "qualname": "SimParm.SIM_OFFSET", "kind": "variable", "doc": "<p></p>\n", "default_value": "2.5"}, {"fullname": "Sim.SimConfig.SimParm.SIM_FPS", "modulename": "Sim.SimConfig", "qualname": "SimParm.SIM_FPS", "kind": "variable", "doc": "<p></p>\n", "default_value": "100"}, {"fullname": "Sim.SimConfig.SimParm.SIM_FRICTION", "modulename": "Sim.SimConfig", "qualname": "SimParm.SIM_FRICTION", "kind": "variable", "doc": "<p></p>\n", "default_value": "0.98"}, {"fullname": "Sim.SimConfig.SimParm.GATE_Y_START", "modulename": "Sim.SimConfig", "qualname": "SimParm.GATE_Y_START", "kind": "variable", "doc": "<p></p>\n", "default_value": "1.5"}, {"fullname": "Sim.SimConfig.SimParm.MAX_GATE_WIDTH", "modulename": "Sim.SimConfig", "qualname": "SimParm.MAX_GATE_WIDTH", "kind": "variable", "doc": "<p></p>\n", "default_value": "0.65"}, {"fullname": "Sim.SimConfig.SimParm.BALL_GATE_CENTER", "modulename": "Sim.SimConfig", "qualname": "SimParm.BALL_GATE_CENTER", "kind": "variable", "doc": "<p></p>\n", "default_value": "0.3"}, {"fullname": "Sim.SimConfig.SimParm.MIN_DIS_START", "modulename": "Sim.SimConfig", "qualname": "SimParm.MIN_DIS_START", "kind": "variable", "doc": "<p></p>\n", "default_value": "0.6"}, {"fullname": "Sim.SimConfig.SimParm.MAX_DIS_START", "modulename": "Sim.SimConfig", "qualname": "SimParm.MAX_DIS_START", "kind": "variable", "doc": "<p></p>\n", "default_value": "2"}, {"fullname": "Sim.SimConfig.SimParm.CAMERA_FOV", "modulename": "Sim.SimConfig", "qualname": "SimParm.CAMERA_FOV", "kind": "variable", "doc": "<p></p>\n", "default_value": "1.0471975511965976"}, {"fullname": "Sim.SimConfig.SimParm.FOV_LINE_LENGTH", "modulename": "Sim.SimConfig", "qualname": "SimParm.FOV_LINE_LENGTH", "kind": "variable", "doc": "<p></p>\n", "default_value": "2000"}, {"fullname": "Sim.SimConfig.SimParm.TUBE_RADIUS", "modulename": "Sim.SimConfig", "qualname": "SimParm.TUBE_RADIUS", "kind": "variable", "doc": "<p></p>\n", "default_value": "0.05"}, {"fullname": "Sim.SimConfig.SimParm.TURTLE_RADIUS", "modulename": "Sim.SimConfig", "qualname": "SimParm.TURTLE_RADIUS", "kind": "variable", "doc": "<p></p>\n", "default_value": "0.2"}, {"fullname": "Sim.SimConfig.SimParm.BALL_RADIUS", "modulename": "Sim.SimConfig", "qualname": "SimParm.BALL_RADIUS", "kind": "variable", "doc": "<p></p>\n", "default_value": "0.22"}, {"fullname": "Sim.SimConfig.DataClasses", "modulename": "Sim.SimConfig", "qualname": "DataClasses", "kind": "class", "doc": "<p>Enum for data classes</p>\n", "bases": "enum.IntEnum"}, {"fullname": "Sim.SimConfig.DataClasses.GREEN", "modulename": "Sim.SimConfig", "qualname": "DataClasses.GREEN", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;DataClasses.GREEN: 0&gt;"}, {"fullname": "Sim.SimConfig.DataClasses.RED", "modulename": "Sim.SimConfig", "qualname": "DataClasses.RED", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;DataClasses.RED: 1&gt;"}, {"fullname": "Sim.SimConfig.DataClasses.BLUE", "modulename": "Sim.SimConfig", "qualname": "DataClasses.BLUE", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;DataClasses.BLUE: 2&gt;"}, {"fullname": "Sim.SimConfig.DataClasses.BALL", "modulename": "Sim.SimConfig", "qualname": "DataClasses.BALL", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;DataClasses.BALL: 3&gt;"}, {"fullname": "Sim.SimConfig.DataClasses.TURTLE", "modulename": "Sim.SimConfig", "qualname": "DataClasses.TURTLE", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;DataClasses.TURTLE: 4&gt;"}, {"fullname": "Sim.SimConfig.DataClasses.POINT", "modulename": "Sim.SimConfig", "qualname": "DataClasses.POINT", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;DataClasses.POINT: 5&gt;"}, {"fullname": "Sim.SimObjects", "modulename": "Sim.SimObjects", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "Sim.SimObjects.Objects", "modulename": "Sim.SimObjects", "qualname": "Objects", "kind": "class", "doc": "<p>A class to represent objects in a simulation.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>sim (object):</strong>  The simulation instance the object belongs to.</li>\n<li><strong>type (str, optional):</strong>  The type of the object. Defaults to None.</li>\n<li><strong>RADIUS (int):</strong>  The radius of the object. Defaults to 0.</li>\n<li><strong>pos (numpy.ndarray):</strong>  The position of the object as a 2D array. Initialized if x and y are provided.</li>\n</ul>\n\n<h6 id=\"methods\">Methods:</h6>\n\n<blockquote>\n  <p>DimToPixels(dim_real):\n      Converts a real-world dimension to pixels based on simulation parameters.\n  was_collision(collission_pos, radius):\n      Checks if a collision occurred with another object based on its position and radius.\n  get_position():\n      Returns the current position of the object.</p>\n</blockquote>\n"}, {"fullname": "Sim.SimObjects.Objects.__init__", "modulename": "Sim.SimObjects", "qualname": "Objects.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">sim</span>, </span><span class=\"param\"><span class=\"nb\">type</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">x</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">y</span><span class=\"o\">=</span><span class=\"kc\">None</span></span>)</span>"}, {"fullname": "Sim.SimObjects.Objects.sim", "modulename": "Sim.SimObjects", "qualname": "Objects.sim", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "Sim.SimObjects.Objects.type", "modulename": "Sim.SimObjects", "qualname": "Objects.type", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "Sim.SimObjects.Objects.RADIUS", "modulename": "Sim.SimObjects", "qualname": "Objects.RADIUS", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "Sim.SimObjects.Objects.DimToPixels", "modulename": "Sim.SimObjects", "qualname": "Objects.DimToPixels", "kind": "function", "doc": "<p>Converts a real-world dimension to its equivalent in pixels.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>dim_real (float):</strong>  The real-world dimension to be converted.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>int: The dimension in pixels, calculated based on the ratio of\n       simulation width in pixels to the real-world side length.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">dim_real</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "Sim.SimObjects.Objects.was_collision", "modulename": "Sim.SimObjects", "qualname": "Objects.was_collision", "kind": "function", "doc": "<p>Determines whether a collision has occurred between the object and another object.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>collission_pos (numpy.ndarray):</strong>  The position of the other object as a NumPy array.</li>\n<li><strong>radius (float):</strong>  The radius of the other object.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if a collision has occurred, False otherwise.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">collission_pos</span>, </span><span class=\"param\"><span class=\"n\">radius</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "Sim.SimObjects.Objects.get_position", "modulename": "Sim.SimObjects", "qualname": "Objects.get_position", "kind": "function", "doc": "<p>Retrieve the current position of the object.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>tuple: The current position of the object as a tuple (e.g., (x, y)).</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "Sim.SimObjects.PlayGround", "modulename": "Sim.SimObjects", "qualname": "PlayGround", "kind": "class", "doc": "<p>A class representing the playground in the simulation.</p>\n\n<h6 id=\"inherits-from\">Inherits from:</h6>\n\n<blockquote>\n  <p>Objects: The base class for simulation objects.</p>\n</blockquote>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>sim (object):</strong>  The simulation instance to which the playground belongs.</li>\n<li><strong>type (str, optional):</strong>  The type of the object. Defaults to None.</li>\n<li><strong>x (float, optional):</strong>  The x-coordinate of the object. Defaults to None.</li>\n<li><strong>y (float, optional):</strong>  The y-coordinate of the object. Defaults to None.</li>\n</ul>\n\n<h6 id=\"methods\">Methods:</h6>\n\n<blockquote>\n  <p>__init__(sim, type=None, x=None, y=None):\n      Initializes a PlayGround object with the given simulation instance,\n      type, and coordinates.\n  draw():\n      Draws the playground on the simulation screen. This includes filling\n      the screen with a white background and drawing lines to represent\n      specific areas of the playground.</p>\n</blockquote>\n", "bases": "Objects"}, {"fullname": "Sim.SimObjects.PlayGround.__init__", "modulename": "Sim.SimObjects", "qualname": "PlayGround.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">sim</span>, </span><span class=\"param\"><span class=\"nb\">type</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">x</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">y</span><span class=\"o\">=</span><span class=\"kc\">None</span></span>)</span>"}, {"fullname": "Sim.SimObjects.PlayGround.draw", "modulename": "Sim.SimObjects", "qualname": "PlayGround.draw", "kind": "function", "doc": "<p>Draws the simulation environment on the screen.\nThis method clears the screen, draws dividing lines, and highlights specific\nregions of interest in the simulation using colored lines.</p>\n\n<ul>\n<li>Fills the screen with a white background.</li>\n<li>Draws a black vertical line in the middle of the screen.</li>\n<li>Draws two horizontal red lines at specific positions determined by the\n<code>DimToPixels</code> method.\nThe positions and colors of the lines are defined by the <code>SimParm</code> class.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "Sim.SimObjects.Turtle", "modulename": "Sim.SimObjects", "qualname": "Turtle", "kind": "class", "doc": "<p>Represents a TurtleBot object in the simulation.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>angle (float):</strong>  The current orientation of the TurtleBot in radians.</li>\n<li><strong>last_velosity (float):</strong>  The last recorded velocity of the TurtleBot.</li>\n<li><strong>RADIUS (float):</strong>  The radius of the TurtleBot, defined in simulation parameters.</li>\n</ul>\n\n<h6 id=\"methods\">Methods:</h6>\n\n<blockquote>\n  <p>__init__(sim, type, x, y, angle):\n      Initializes a TurtleBot object with its simulation context, type, position, and angle.\n  draw():\n      Draws the TurtleBot on the simulation screen, including its position, orientation, and field of view.\n  move(velocity, angular_velocity, forward=True, clockwise=True):\n      Moves the TurtleBot based on the given velocity and angular velocity.\n      The direction of movement can be controlled using the <code>forward</code> and <code>clockwise</code> flags.\n  get_info():\n      Returns the current state of the TurtleBot as a NumPy array, including position, angle, and last velocity.</p>\n</blockquote>\n", "bases": "Objects"}, {"fullname": "Sim.SimObjects.Turtle.__init__", "modulename": "Sim.SimObjects", "qualname": "Turtle.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">sim</span>, </span><span class=\"param\"><span class=\"nb\">type</span>, </span><span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">y</span>, </span><span class=\"param\"><span class=\"n\">angle</span></span>)</span>"}, {"fullname": "Sim.SimObjects.Turtle.angle", "modulename": "Sim.SimObjects", "qualname": "Turtle.angle", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "Sim.SimObjects.Turtle.last_velosity", "modulename": "Sim.SimObjects", "qualname": "Turtle.last_velosity", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "Sim.SimObjects.Turtle.RADIUS", "modulename": "Sim.SimObjects", "qualname": "Turtle.RADIUS", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "Sim.SimObjects.Turtle.draw", "modulename": "Sim.SimObjects", "qualname": "Turtle.draw", "kind": "function", "doc": "<p>Draws the TurtleBot on the simulation screen.\nThis method visualizes the TurtleBot's position, orientation, and field of view (FOV)\non the simulation screen using Pygame. It includes:</p>\n\n<ul>\n<li>A circle representing the TurtleBot's body.</li>\n<li>A line indicating the front direction of the TurtleBot.</li>\n<li>Two lines representing the edges of the TurtleBot's camera field of view.\nThe drawing is scaled and positioned based on the TurtleBot's current position,\norientation, and dimensions.</li>\n</ul>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>self.pos (tuple):</strong>  The (x, y) position of the TurtleBot in the simulation.</li>\n<li><strong>self.angle (float):</strong>  The orientation angle of the TurtleBot in radians.</li>\n<li><strong>self.RADIUS (float):</strong>  The radius of the TurtleBot.</li>\n<li><strong>self.sim.screen (pygame.Surface):</strong>  The Pygame surface where the TurtleBot is drawn.</li>\n<li><strong>SimParm.RED (tuple):</strong>  The RGB color for the TurtleBot's body.</li>\n<li><strong>SimParm.BLACK (tuple):</strong>  The RGB color for the lines.</li>\n<li><strong>SimParm.CAMERA_FOV (float):</strong>  The field of view angle of the TurtleBot's camera in radians.</li>\n<li><strong>SimParm.FOV_LINE_LENGTH (float):</strong>  The length of the FOV lines.</li>\n</ul>\n\n<h6 id=\"note\">Note:</h6>\n\n<blockquote>\n  <p>The <code>DimToPixels</code> method is used to convert dimensions from simulation units\n  to pixel units for rendering on the screen.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "Sim.SimObjects.Turtle.move", "modulename": "Sim.SimObjects", "qualname": "Turtle.move", "kind": "function", "doc": "<p>Moves the robot based on the specified velocity and angular velocity.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>velocity (float):</strong>  The linear velocity of the robot.</li>\n<li><strong>angular_velocity (float):</strong>  The angular velocity of the robot.</li>\n<li><strong>forward (bool, optional):</strong>  If True, the robot moves forward. If False, the robot moves backward. Defaults to True.</li>\n<li><strong>clockwise (bool, optional):</strong>  If True, the robot rotates clockwise. If False, the robot rotates counterclockwise. Defaults to True.</li>\n</ul>\n\n<h6 id=\"updates\">Updates:</h6>\n\n<blockquote>\n  <ul>\n  <li>The robot's angle is adjusted based on the angular velocity and direction.</li>\n  <li>The robot's position is updated based on the linear velocity, direction, and current angle.</li>\n  <li>The <code>last_velocity</code> attribute is set to the provided velocity.</li>\n  </ul>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">velocity</span>, </span><span class=\"param\"><span class=\"n\">angular_velocity</span>, </span><span class=\"param\"><span class=\"n\">forward</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"n\">clockwise</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "Sim.SimObjects.Turtle.get_info", "modulename": "Sim.SimObjects", "qualname": "Turtle.get_info", "kind": "function", "doc": "<p>Retrieve information about the object's current state.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>numpy.ndarray: A 1D array containing the following elements:\n      - self.pos[0] (float): The x-coordinate of the object's position.\n      - self.pos[1] (float): The y-coordinate of the object's position.\n      - self.angle (float): The object's current angle or orientation.\n      - self.last_velosity (float): The object's last recorded velocity.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "Sim.SimObjects.Tube", "modulename": "Sim.SimObjects", "qualname": "Tube", "kind": "class", "doc": "<p>Represents a tube object in the simulation.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>color (tuple or None):</strong>  The color of the tube, represented as an RGB tuple. Defaults to None.</li>\n<li><strong>RADIUS (float):</strong>  The radius of the tube, defined as a constant from SimParm.TUBE_RADIUS.</li>\n</ul>\n\n<h6 id=\"methods\">Methods:</h6>\n\n<blockquote>\n  <p>__init__(sim, type, x, y, color=None):\n      Initializes a Tube object with its simulation context, type, position, and optional color.\n  draw():\n      Draws the tube on the simulation screen as a circle.</p>\n</blockquote>\n", "bases": "Objects"}, {"fullname": "Sim.SimObjects.Tube.__init__", "modulename": "Sim.SimObjects", "qualname": "Tube.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">sim</span>, </span><span class=\"param\"><span class=\"nb\">type</span>, </span><span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">y</span>, </span><span class=\"param\"><span class=\"n\">color</span><span class=\"o\">=</span><span class=\"kc\">None</span></span>)</span>"}, {"fullname": "Sim.SimObjects.Tube.color", "modulename": "Sim.SimObjects", "qualname": "Tube.color", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "Sim.SimObjects.Tube.RADIUS", "modulename": "Sim.SimObjects", "qualname": "Tube.RADIUS", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "Sim.SimObjects.Tube.draw", "modulename": "Sim.SimObjects", "qualname": "Tube.draw", "kind": "function", "doc": "<p>Draws the object as a circle on the simulation screen.\nThis method uses the pygame library to draw a circle representing the object.\nThe circle's position, color, and radius are determined by the object's attributes.\nThe position and radius are converted from simulation dimensions to pixel dimensions\nusing the <code>DimToPixels</code> method.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>self.sim.screen (pygame.Surface):</strong>  The surface on which the object is drawn.</li>\n<li><strong>self.color (tuple):</strong>  The color of the circle in RGB format.</li>\n<li><strong>self.pos (tuple):</strong>  The position of the object in simulation dimensions.</li>\n<li><strong>self.RADIUS (float):</strong>  The radius of the object in simulation dimensions.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "Sim.SimObjects.Ball", "modulename": "Sim.SimObjects", "qualname": "Ball", "kind": "class", "doc": "<p>A class to represent objects in a simulation.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>sim (object):</strong>  The simulation instance the object belongs to.</li>\n<li><strong>type (str, optional):</strong>  The type of the object. Defaults to None.</li>\n<li><strong>RADIUS (int):</strong>  The radius of the object. Defaults to 0.</li>\n<li><strong>pos (numpy.ndarray):</strong>  The position of the object as a 2D array. Initialized if x and y are provided.</li>\n</ul>\n\n<h6 id=\"methods\">Methods:</h6>\n\n<blockquote>\n  <p>DimToPixels(dim_real):\n      Converts a real-world dimension to pixels based on simulation parameters.\n  was_collision(collission_pos, radius):\n      Checks if a collision occurred with another object based on its position and radius.\n  get_position():\n      Returns the current position of the object.</p>\n</blockquote>\n", "bases": "Objects"}, {"fullname": "Sim.SimObjects.Ball.__init__", "modulename": "Sim.SimObjects", "qualname": "Ball.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">sim</span>, </span><span class=\"param\"><span class=\"nb\">type</span>, </span><span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">y</span>, </span><span class=\"param\"><span class=\"n\">color</span><span class=\"o\">=</span><span class=\"kc\">None</span></span>)</span>"}, {"fullname": "Sim.SimObjects.Ball.RADIUS", "modulename": "Sim.SimObjects", "qualname": "Ball.RADIUS", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "Sim.SimObjects.Ball.velocity", "modulename": "Sim.SimObjects", "qualname": "Ball.velocity", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "Sim.SimObjects.Ball.draw", "modulename": "Sim.SimObjects", "qualname": "Ball.draw", "kind": "function", "doc": "<p>Draw the objects.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "Sim.SimObjects.Ball.movement", "modulename": "Sim.SimObjects", "qualname": "Ball.movement", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "Sim.SimObjects.Ball.set_velocity", "modulename": "Sim.SimObjects", "qualname": "Ball.set_velocity", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">new_velocity</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "Sim.SimObjects.Point", "modulename": "Sim.SimObjects", "qualname": "Point", "kind": "class", "doc": "<p>A class to represent objects in a simulation.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>sim (object):</strong>  The simulation instance the object belongs to.</li>\n<li><strong>type (str, optional):</strong>  The type of the object. Defaults to None.</li>\n<li><strong>RADIUS (int):</strong>  The radius of the object. Defaults to 0.</li>\n<li><strong>pos (numpy.ndarray):</strong>  The position of the object as a 2D array. Initialized if x and y are provided.</li>\n</ul>\n\n<h6 id=\"methods\">Methods:</h6>\n\n<blockquote>\n  <p>DimToPixels(dim_real):\n      Converts a real-world dimension to pixels based on simulation parameters.\n  was_collision(collission_pos, radius):\n      Checks if a collision occurred with another object based on its position and radius.\n  get_position():\n      Returns the current position of the object.</p>\n</blockquote>\n", "bases": "Objects"}, {"fullname": "Sim.SimObjects.Point.__init__", "modulename": "Sim.SimObjects", "qualname": "Point.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">sim</span>, </span><span class=\"param\"><span class=\"nb\">type</span>, </span><span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">y</span>, </span><span class=\"param\"><span class=\"n\">color</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span></span>)</span>"}, {"fullname": "Sim.SimObjects.Point.Point", "modulename": "Sim.SimObjects", "qualname": "Point.Point", "kind": "class", "doc": "<p>A class representing a point object in a simulation.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>sim (object):</strong>  The simulation instance the point belongs to.</li>\n<li><strong>type (str):</strong>  The type of the point object.</li>\n<li><strong>x (float):</strong>  The x-coordinate of the point.</li>\n<li><strong>y (float):</strong>  The y-coordinate of the point.</li>\n<li><strong>color (tuple):</strong>  The color of the point, default is SimParm.BLACK.</li>\n</ul>\n\n<h6 id=\"methods\">Methods:</h6>\n\n<blockquote>\n  <p>__del__():\n      Destructor for the Point class, cleans up resources.\n  set_position(x, y):\n      Sets the position of the point using the given x and y coordinates.\n  draw():\n      Draws the point on the simulation screen as a circle.</p>\n</blockquote>\n"}, {"fullname": "Sim.SimObjects.Point.Point.color", "modulename": "Sim.SimObjects", "qualname": "Point.Point.color", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "Sim.SimObjects.Point.Point.x", "modulename": "Sim.SimObjects", "qualname": "Point.Point.x", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "Sim.SimObjects.Point.Point.y", "modulename": "Sim.SimObjects", "qualname": "Point.Point.y", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "Sim.SimObjects.Point.color", "modulename": "Sim.SimObjects", "qualname": "Point.color", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "Sim.SimObjects.Point.x", "modulename": "Sim.SimObjects", "qualname": "Point.x", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "Sim.SimObjects.Point.y", "modulename": "Sim.SimObjects", "qualname": "Point.y", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "Sim.SimObjects.Point.set_position", "modulename": "Sim.SimObjects", "qualname": "Point.set_position", "kind": "function", "doc": "<p>Set the position of the object.\nParameters:\nx (float): The x-coordinate of the new position.\ny (float): The y-coordinate of the new position.\nReturns:\nNone</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">y</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "Sim.SimObjects.Point.draw", "modulename": "Sim.SimObjects", "qualname": "Point.draw", "kind": "function", "doc": "<p>Draws the object on the simulation screen as a circle.\nThis method uses the pygame library to render a circle representing the object.\nThe circle's position, color, and size are determined by the object's attributes.\nThe position is converted from simulation dimensions to pixel coordinates using\nthe <code>DimToPixels</code> method. The radius of the circle is fixed at 0.1 in simulation\ndimensions, which is also converted to pixels.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "Sim.SimObjects.Path", "modulename": "Sim.SimObjects", "qualname": "Path", "kind": "class", "doc": "<p>A class to represent objects in a simulation.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>sim (object):</strong>  The simulation instance the object belongs to.</li>\n<li><strong>type (str, optional):</strong>  The type of the object. Defaults to None.</li>\n<li><strong>RADIUS (int):</strong>  The radius of the object. Defaults to 0.</li>\n<li><strong>pos (numpy.ndarray):</strong>  The position of the object as a 2D array. Initialized if x and y are provided.</li>\n</ul>\n\n<h6 id=\"methods\">Methods:</h6>\n\n<blockquote>\n  <p>DimToPixels(dim_real):\n      Converts a real-world dimension to pixels based on simulation parameters.\n  was_collision(collission_pos, radius):\n      Checks if a collision occurred with another object based on its position and radius.\n  get_position():\n      Returns the current position of the object.</p>\n</blockquote>\n", "bases": "Objects"}, {"fullname": "Sim.SimObjects.Path.__init__", "modulename": "Sim.SimObjects", "qualname": "Path.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">sim</span>, </span><span class=\"param\"><span class=\"n\">color</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span></span>)</span>"}, {"fullname": "Sim.SimObjects.Path.Path", "modulename": "Sim.SimObjects", "qualname": "Path.Path", "kind": "class", "doc": "<p>A class representing a path consisting of multiple points.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>points (list):</strong>  A list of Point objects representing the path.</li>\n<li><strong>color (tuple):</strong>  The color of the path, default is SimParm.BLACK.</li>\n<li><strong>sim (object):</strong>  The simulation object associated with the path.</li>\n</ul>\n\n<h6 id=\"methods\">Methods:</h6>\n\n<blockquote>\n  <p>__del__():\n      Destructor for the Path class. Cleans up the points list.\n  add_point(point):\n      Adds a new point to the path.\n      Args:\n          point (tuple): A tuple containing the x and y coordinates of the point.\n  draw():\n      Draws the path by connecting the points with lines on the simulation screen.</p>\n</blockquote>\n"}, {"fullname": "Sim.SimObjects.Path.Path.points", "modulename": "Sim.SimObjects", "qualname": "Path.Path.points", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "Sim.SimObjects.Path.Path.color", "modulename": "Sim.SimObjects", "qualname": "Path.Path.color", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "Sim.SimObjects.Path.Path.sim", "modulename": "Sim.SimObjects", "qualname": "Path.Path.sim", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "Sim.SimObjects.Path.points", "modulename": "Sim.SimObjects", "qualname": "Path.points", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "Sim.SimObjects.Path.color", "modulename": "Sim.SimObjects", "qualname": "Path.color", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "Sim.SimObjects.Path.sim", "modulename": "Sim.SimObjects", "qualname": "Path.sim", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "Sim.SimObjects.Path.add_point", "modulename": "Sim.SimObjects", "qualname": "Path.add_point", "kind": "function", "doc": "<p>Adds a new point to the list of points.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>point (tuple):</strong>  A tuple containing the x and y coordinates of the point\nto be added (e.g., (x, y)).</li>\n</ul>\n\n<h6 id=\"creates\">Creates:</h6>\n\n<blockquote>\n  <p>A new <code>Point</code> object with the specified coordinates, associated with\n  the current simulation (<code>sim</code>), and appends it to the <code>points</code> list.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">point</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "Sim.SimObjects.Path.draw", "modulename": "Sim.SimObjects", "qualname": "Path.draw", "kind": "function", "doc": "<p>Draws lines connecting a sequence of points on the simulation screen.\nThis method iterates through the list of points and draws a line between\neach consecutive pair of points. The lines are drawn using the specified\ncolor and a fixed thickness.\nUses the <code>DimToPixels</code> method to convert the coordinates of the points\nfrom simulation dimensions to pixel dimensions.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li>None</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();