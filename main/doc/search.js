window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "run", "modulename": "run", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "run.MainControl", "modulename": "run", "qualname": "MainControl", "kind": "class", "doc": "<p>MainControl class is responsible for managing the robot's main control loop,\nhandling  SLAM (Simultaneous Localization and Mapping),\npath planning, and velocity control.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>turtle (Turtlebot):</strong>  Instance of the Turtlebot class for robot control.</li>\n<li><strong>end_event (Event):</strong>  Event to signal the end of the program.</li>\n<li><strong>start_event (Event):</strong>  Event to signal the start of the mission.</li>\n<li><strong>velocity_control (VelocityControl):</strong>  Handles velocity commands for the robot.</li>\n<li><strong>camera (OnnxCamera):</strong>  Object detection class.</li>\n<li><strong>slam (UKF_SLAM):</strong>  SLAM classs.</li>\n<li><strong>odo (Odometry):</strong>  Odometry class.</li>\n<li><strong>path_planning (Planning):</strong>  Path planning  class for navigation.</li>\n</ul>\n\n<h6 id=\"methods\">Methods:</h6>\n\n<blockquote>\n  <p>__init__():\n      Initializes the MainControl class, sets up the robot, SLAM, and other components.\n  bumper_callback(msg):\n      Callback function triggered when the bumper is pressed.\n  button_callback(msg):\n      Callback function triggered when the button is pressed.\n  run():\n      Main control loop for the robot. Handles sensor data, SLAM updates,\n      path planning, and robot motion.</p>\n</blockquote>\n"}, {"fullname": "run.MainControl.turtle", "modulename": "run", "qualname": "MainControl.turtle", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "run.MainControl.end_event", "modulename": "run", "qualname": "MainControl.end_event", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "run.MainControl.start_event", "modulename": "run", "qualname": "MainControl.start_event", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "run.MainControl.velocity_control", "modulename": "run", "qualname": "MainControl.velocity_control", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "run.MainControl.camera", "modulename": "run", "qualname": "MainControl.camera", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "run.MainControl.slam", "modulename": "run", "qualname": "MainControl.slam", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "run.MainControl.odo", "modulename": "run", "qualname": "MainControl.odo", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "run.MainControl.path_planning", "modulename": "run", "qualname": "MainControl.path_planning", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "run.MainControl.slam_poses", "modulename": "run", "qualname": "MainControl.slam_poses", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "run.MainControl.points", "modulename": "run", "qualname": "MainControl.points", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "run.MainControl.ball", "modulename": "run", "qualname": "MainControl.ball", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "run.MainControl.bumper_callback", "modulename": "run", "qualname": "MainControl.bumper_callback", "kind": "function", "doc": "<p>Callback function triggered when the bumper state changes.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>msg:</strong>  A message object containing the state of the bumper.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">msg</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "run.MainControl.button_callback", "modulename": "run", "qualname": "MainControl.button_callback", "kind": "function", "doc": "<p>Callback function triggered by a button press event used for starting the mission.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>msg:</strong>  An object containing the state of the button.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">msg</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "run.MainControl.run", "modulename": "run", "qualname": "MainControl.run", "kind": "function", "doc": "<p>The <code>run</code> method is the main execution loop for the robot's operation. It handles sensor data processing,\nSLAM (Simultaneous Localization and Mapping), path planning, and velocity control. The method also\nvisualizes the SLAM process and generates a final plot of the robot's path and detected landmarks.\nThe method continuously runs until the robot is shut down or a goal is reached.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "algorithms", "modulename": "algorithms", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "algorithms.PathPlanning", "modulename": "algorithms.PathPlanning", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "algorithms.PathPlanning.Planning", "modulename": "algorithms.PathPlanning", "qualname": "Planning", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "algorithms.PathPlanning.Planning.objects", "modulename": "algorithms.PathPlanning", "qualname": "Planning.objects", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.PathPlanning.Planning.goal_targer", "modulename": "algorithms.PathPlanning", "qualname": "Planning.goal_targer", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.PathPlanning.Planning.ball_pos", "modulename": "algorithms.PathPlanning", "qualname": "Planning.ball_pos", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.PathPlanning.Planning.ball_path", "modulename": "algorithms.PathPlanning", "qualname": "Planning.ball_path", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.PathPlanning.Planning.robot_pos", "modulename": "algorithms.PathPlanning", "qualname": "Planning.robot_pos", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.PathPlanning.Planning.time_to_shoot", "modulename": "algorithms.PathPlanning", "qualname": "Planning.time_to_shoot", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.PathPlanning.Planning.create_path", "modulename": "algorithms.PathPlanning", "qualname": "Planning.create_path", "kind": "function", "doc": "<p>Returns next point in a path or robot path and ball path if test_alg is true</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>object_pos (list):</strong>  List of objects positions and classes</li>\n<li><strong>robot_pos (list):</strong>  Position of the robot</li>\n<li><strong>test_alg (bool):</strong>  If True, returns all paths for testing</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: Next point in the path for the robot to follow</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">object_pos</span>, </span><span class=\"param\"><span class=\"n\">robot_pos</span>, </span><span class=\"param\"><span class=\"n\">test_alg</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "algorithms.PathPlanning.Planning.clear_objects", "modulename": "algorithms.PathPlanning", "qualname": "Planning.clear_objects", "kind": "function", "doc": "<p>Clears all objectss.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "algorithms.PathPlanning.Planning.same_hading", "modulename": "algorithms.PathPlanning", "qualname": "Planning.same_hading", "kind": "function", "doc": "<p>Checks if the robot is in the same direction as the vector.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>vector (np.ndarray):</strong>  Vector to check</li>\n<li><strong>angle (float):</strong>  Angle of the robot</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if the robot is in the same direction as the vector, False otherwise</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">vector</span>, </span><span class=\"param\"><span class=\"n\">angle</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "algorithms.PathPlanning.Planning.turn_robot_around", "modulename": "algorithms.PathPlanning", "qualname": "Planning.turn_robot_around", "kind": "function", "doc": "<p>Turns the robot around by -90 degrees.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>center (np.ndarray):</strong>  Center of the robot</li>\n<li><strong>angle (float):</strong>  Angle of the robot</li>\n<li><strong>distance (float):</strong>  Scale of turning vector</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: New position to turn to.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">center</span>, </span><span class=\"param\"><span class=\"n\">angle</span>, </span><span class=\"param\"><span class=\"n\">distance</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "algorithms.PathPlanning.Planning.identify_objects", "modulename": "algorithms.PathPlanning", "qualname": "Planning.identify_objects", "kind": "function", "doc": "<p>Indenfify objects and add them to the objects list</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>objects_in (np.ndarray):</strong>  List of objects positions and classes</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>ErrorCodes: Error code for the outcome of the function</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">objects_in</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "algorithms.PathPlanning.Planning.solve_more_blue_tubes", "modulename": "algorithms.PathPlanning", "qualname": "Planning.solve_more_blue_tubes", "kind": "function", "doc": "<p>Solves the problem of more than 2 blue tubes by returning the first blue tube or the goal target if it exists</p>\n\n<h6 id=\"retuns\">Retuns:</h6>\n\n<blockquote>\n  <p>np.ndarray: Position of the blue tube or goal target</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "algorithms.PathPlanning.Planning.is_goal", "modulename": "algorithms.PathPlanning", "qualname": "Planning.is_goal", "kind": "function", "doc": "<p>Checks if the ball is in the goal.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if the ball is in the goal, False otherwise</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "algorithms.PathPlanning.Planning.generate_trajectory", "modulename": "algorithms.PathPlanning", "qualname": "Planning.generate_trajectory", "kind": "function", "doc": "<p>Gernerates a path from start to target point and avoids one obstacle point.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>start (np.ndarray):</strong>  Start point</li>\n<li><strong>target (np.ndarray):</strong>  Target point</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: Path points</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">start</span>, </span><span class=\"param\"><span class=\"n\">target</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "algorithms.PathPlanning.Planning.generate_way_around", "modulename": "algorithms.PathPlanning", "qualname": "Planning.generate_way_around", "kind": "function", "doc": "<p>Generates a path around the problem point by finding the shortest path through the tangent points.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>start (np.ndarray):</strong>  Start point</li>\n<li><strong>end (np.ndarray):</strong>  End point</li>\n<li><strong>problem (np.ndarray):</strong>  Problem point</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: Path points for the alternative path</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">start</span>, </span><span class=\"param\"><span class=\"n\">end</span>, </span><span class=\"param\"><span class=\"n\">problem</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "algorithms.PathPlanning.Planning.generate_shoot_path", "modulename": "algorithms.PathPlanning", "qualname": "Planning.generate_shoot_path", "kind": "function", "doc": "<p>Generates a shooting point for the robot and a path to the ball</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: Shooting point and overshoot point</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "algorithms.PathPlanning.Planning.check_colisions", "modulename": "algorithms.PathPlanning", "qualname": "Planning.check_colisions", "kind": "function", "doc": "<p>Checks if there are any collisions with the path between the start and end points and returns the collision point if there is one.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>path (np.ndarray):</strong>  Path points</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: Collision point if there is one, else None</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">path</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "algorithms.PathPlanning.Planning.check_colision_from_class", "modulename": "algorithms.PathPlanning", "qualname": "Planning.check_colision_from_class", "kind": "function", "doc": "<p>Checks for colision with specified class of objects and returns the colision point if there is one.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>path (np.ndarray):</strong>  Path points</li>\n<li><strong>data_class (DataClasses):</strong>  Class of objects</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: Collision point if there is one, else None</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">path</span>, </span><span class=\"param\"><span class=\"n\">data_class</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "algorithms.PathPlanning.Planning.point_distance_from_line", "modulename": "algorithms.PathPlanning", "qualname": "Planning.point_distance_from_line", "kind": "function", "doc": "<p>Calculates the perpendicular distance of a point from the line defined by points A and B.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>P (np.ndarray):</strong>  Point to check</li>\n<li><strong>A (np.ndarray):</strong>  Start point of the line</li>\n<li><strong>B (np.ndarray):</strong>  End point of the line</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>float: Distance from the point to the line</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">P</span>, </span><span class=\"param\"><span class=\"n\">A</span>, </span><span class=\"param\"><span class=\"n\">B</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "algorithms.PathPlanning.Planning.find_tangent_points", "modulename": "algorithms.PathPlanning", "qualname": "Planning.find_tangent_points", "kind": "function", "doc": "<p>Finds two tangent points from start point to circle.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>start (np.ndarray):</strong>  Start point</li>\n<li><strong>center (np.ndarray):</strong>  Center of the object</li>\n<li><strong>radius (float):</strong>  Radius of the object perimeter</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: First tangent point\n  np.ndarray: Second tangent point</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">start</span>, </span><span class=\"param\"><span class=\"n\">center</span>, </span><span class=\"param\"><span class=\"n\">radius</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "algorithms.PathPlanning.Planning.mat_rot", "modulename": "algorithms.PathPlanning", "qualname": "Planning.mat_rot", "kind": "function", "doc": "<p>Returns a rotation matrix for a given angle</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>angle (float):</strong>  Angle in radians</li>\n<li><strong>vector (np.ndarray):</strong>  Vector to rotate</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: Rotated vector</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">angle</span>, </span><span class=\"param\"><span class=\"n\">vector</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "algorithms.PathPlanning.Planning.path_length", "modulename": "algorithms.PathPlanning", "qualname": "Planning.path_length", "kind": "function", "doc": "<p>Calculates the total length of a line.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>float:</strong>  Length of the line.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">points</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "algorithms.PathPlanning.Planning.find_intersection", "modulename": "algorithms.PathPlanning", "qualname": "Planning.find_intersection", "kind": "function", "doc": "<p>Finds the intersection point of two lines defined by two points each.</p>\n\n<ol>\n<li>lineA: (lineA_a, lineA_b)</li>\n<li>lineB: (lineB_a, lineB_b)</li>\n<li>Returns the intersection point if exists, else None</li>\n</ol>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>lineA_a (np.ndarray):</strong>  Start point of line A</li>\n<li><strong>lineA_b (np.ndarray):</strong>  End point of line A</li>\n<li><strong>lineB_a (np.ndarray):</strong>  Start point of line B</li>\n<li><strong>lineB_b (np.ndarray):</strong>  End point of line B</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: Intersection point if exists, else None</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">lineA_a</span>, </span><span class=\"param\"><span class=\"n\">lineA_b</span>, </span><span class=\"param\"><span class=\"n\">lineB_a</span>, </span><span class=\"param\"><span class=\"n\">lineB_b</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "algorithms.PathPlanning.Planning.are_points_in_proximity", "modulename": "algorithms.PathPlanning", "qualname": "Planning.are_points_in_proximity", "kind": "function", "doc": "<p>Checks if two points are within a given proximity.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>point1 (np.ndarray):</strong>  First point</li>\n<li><strong>point2 (np.ndarray):</strong>  Second point</li>\n<li><strong>dis_check (float):</strong>  Distance threshold for proximity check</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if points are within proximity, False otherwise</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">point1</span>, </span><span class=\"param\"><span class=\"n\">point2</span>, </span><span class=\"param\"><span class=\"n\">dis_check</span><span class=\"o\">=</span><span class=\"mf\">0.2</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "algorithms.UKFSlam", "modulename": "algorithms.UKFSlam", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "algorithms.UKFSlam.UKF_SLAM", "modulename": "algorithms.UKFSlam", "qualname": "UKF_SLAM", "kind": "class", "doc": "<p>Unscented Kalman Filter for estimating speed of the robot.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>x (np.ndarray):</strong>  State vector of the robot and landmarks.</li>\n<li><strong>P (np.ndarray):</strong>  Covariance matrix of the state.</li>\n<li><strong>data_cls (np.ndarray):</strong>  Array storing the classes of detected landmarks.</li>\n<li><strong>landmarks (np.ndarray):</strong>  Array of landmarks with their positions and classes.</li>\n<li><strong>alpha (float):</strong>  Scaling parameter for sigma points.</li>\n<li><strong>beta (float):</strong>  Parameter for incorporating prior knowledge of the distribution.</li>\n<li><strong>kappa (float):</strong>  Secondary scaling parameter for sigma points.</li>\n<li><strong>n (int):</strong>  Dimensionality of the state vector.</li>\n<li><strong>lambda_ (float):</strong>  Composite scaling parameter for sigma points.</li>\n<li><strong>Wm (np.ndarray):</strong>  Weights for the mean of sigma points.</li>\n<li><strong>Wc (np.ndarray):</strong>  Weights for the covariance of sigma points.</li>\n<li><strong>landmark_contestants (np.ndarray):</strong>  Temporary storage for potential landmarks.</li>\n</ul>\n\n<h6 id=\"methods\">Methods:</h6>\n\n<blockquote>\n  <p>__init__(x_size, alpha, beta, kappa):\n      Initializes the UKF_SLAM object with state size and filter parameters.\n  sigma_points(x, P):\n      Computes sigma points for the given state mean and covariance.\n  f(x, u):\n      State transition function for predicting the next state.\n  predict(u, old_u):\n      Performs the prediction step of the UKF using odometry data.\n  update(z, h, R):\n      Performs the update step of the UKF using camera detections.\n  data_association(percep_data):\n      Associates perceived data with existing landmarks.\n  update_from_detections(percep_data, time):\n      Updates the state and landmarks based on new detections.</p>\n</blockquote>\n"}, {"fullname": "algorithms.UKFSlam.UKF_SLAM.__init__", "modulename": "algorithms.UKFSlam", "qualname": "UKF_SLAM.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x_size</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">alpha</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">beta</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">kappa</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span>)</span>"}, {"fullname": "algorithms.UKFSlam.UKF_SLAM.x", "modulename": "algorithms.UKFSlam", "qualname": "UKF_SLAM.x", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.UKFSlam.UKF_SLAM.P", "modulename": "algorithms.UKFSlam", "qualname": "UKF_SLAM.P", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.UKFSlam.UKF_SLAM.data_cls", "modulename": "algorithms.UKFSlam", "qualname": "UKF_SLAM.data_cls", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.UKFSlam.UKF_SLAM.landmarks", "modulename": "algorithms.UKFSlam", "qualname": "UKF_SLAM.landmarks", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.UKFSlam.UKF_SLAM.alpha", "modulename": "algorithms.UKFSlam", "qualname": "UKF_SLAM.alpha", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.UKFSlam.UKF_SLAM.beta", "modulename": "algorithms.UKFSlam", "qualname": "UKF_SLAM.beta", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.UKFSlam.UKF_SLAM.kappa", "modulename": "algorithms.UKFSlam", "qualname": "UKF_SLAM.kappa", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.UKFSlam.UKF_SLAM.n", "modulename": "algorithms.UKFSlam", "qualname": "UKF_SLAM.n", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.UKFSlam.UKF_SLAM.lambda_", "modulename": "algorithms.UKFSlam", "qualname": "UKF_SLAM.lambda_", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.UKFSlam.UKF_SLAM.Wm", "modulename": "algorithms.UKFSlam", "qualname": "UKF_SLAM.Wm", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.UKFSlam.UKF_SLAM.Wc", "modulename": "algorithms.UKFSlam", "qualname": "UKF_SLAM.Wc", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.UKFSlam.UKF_SLAM.landmark_contestants", "modulename": "algorithms.UKFSlam", "qualname": "UKF_SLAM.landmark_contestants", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.UKFSlam.UKF_SLAM.sigma_points", "modulename": "algorithms.UKFSlam", "qualname": "UKF_SLAM.sigma_points", "kind": "function", "doc": "<p>Compute sigma points.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>x (np.ndarray):</strong>  mean</li>\n<li><strong>P (np.ndarray):</strong>  covariance</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">P</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "algorithms.UKFSlam.UKF_SLAM.f", "modulename": "algorithms.UKFSlam", "qualname": "UKF_SLAM.f", "kind": "function", "doc": "<p>State transition function.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>x (np.ndarray):</strong>  state</li>\n<li><strong>u (np.ndarray):</strong>  control input</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">u</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "algorithms.UKFSlam.UKF_SLAM.predict", "modulename": "algorithms.UKFSlam", "qualname": "UKF_SLAM.predict", "kind": "function", "doc": "<p>Predict step</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>u (np.ndarray):</strong>  odometry</li>\n<li><strong>old_u (np.ndarray):</strong>  previous odometry</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">old_u</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "algorithms.UKFSlam.UKF_SLAM.update", "modulename": "algorithms.UKFSlam", "qualname": "UKF_SLAM.update", "kind": "function", "doc": "<p>Update step.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>z (np.ndarray):</strong>  measurement</li>\n<li><strong>h (function):</strong>  measurement function - returns in the same shape as z</li>\n<li><strong>R (np.ndarray):</strong>  measurement noise covariance</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">z</span>, </span><span class=\"param\"><span class=\"n\">h</span>, </span><span class=\"param\"><span class=\"n\">R</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "algorithms.UKFSlam.UKF_SLAM.data_association", "modulename": "algorithms.UKFSlam", "qualname": "UKF_SLAM.data_association", "kind": "function", "doc": "<p>Perform data association.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>percep_data (np.ndarray):</strong>  perceived data</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>tuple: A tuple containing:\n      np.ndarray: indices of closest cones\n      np.ndarray: mask for perceived data</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">percep_data</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "algorithms.UKFSlam.UKF_SLAM.update_from_detections", "modulename": "algorithms.UKFSlam", "qualname": "UKF_SLAM.update_from_detections", "kind": "function", "doc": "<p>Updates the state of the SLAM system based on perception data and the current time.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>percep_data (numpy.ndarray):</strong>  A 2D array containing perception data.</li>\n<li><strong>time (float):</strong>  The current timestamp.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">percep_data</span>, </span><span class=\"param\"><span class=\"n\">time</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "algorithms.camera", "modulename": "algorithms.camera", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "algorithms.camera.softmax", "modulename": "algorithms.camera", "qualname": "softmax", "kind": "function", "doc": "<p>Compute the softmax of a given input array.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>x (numpy.ndarray):</strong>  Input array or vector for which to compute the softmax.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>numpy.ndarray: An array of the same shape as the input, where each\n  element represents the softmax probability of the corresponding input element.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "algorithms.camera.xywh2xyxy", "modulename": "algorithms.camera", "qualname": "xywh2xyxy", "kind": "function", "doc": "<p>Convert bounding box format from (x_center, y_center, width, height) to\n(x_min, y_min, x_max, y_max).</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>x (numpy.ndarray):</strong>  A 2D array where each row represents a bounding box\nin the format [x_center, y_center, width, height].</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>numpy.ndarray: A 2D array where each row represents a bounding box\n                 in the format [x_min, y_min, x_max, y_max].</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "algorithms.camera.xyxy2xywh", "modulename": "algorithms.camera", "qualname": "xyxy2xywh", "kind": "function", "doc": "<p>Convert bounding box coordinates from (x_min, y_min, x_max, y_max) format\nto (x_center, y_center, width, height) format.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>x (numpy.ndarray):</strong>  A 2D array where each row represents\na bounding box in the format [x_min, y_min, x_max, y_max].</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>numpy.ndarray: A 2D array  where each row represents\n                 a bounding box in the format [x_center, y_center, width, height].</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "algorithms.camera.OnnxCamera", "modulename": "algorithms.camera", "qualname": "OnnxCamera", "kind": "class", "doc": "<p>A class for performing object detection  using an ONNX model and coordinate transformation.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>cam_K (numpy.ndarray):</strong>  Inverse of the camera intrinsic matrix.</li>\n<li><strong>depth_K (numpy.ndarray):</strong>  Inverse of the depth camera intrinsic matrix.</li>\n<li><strong>cam_to_depth (numpy.ndarray):</strong>  Transformation matrix from camera to depth coordinates.</li>\n<li><strong>verbose (bool):</strong>  Flag to enable verbose logging.</li>\n<li><strong>conf_thresh (float):</strong>  Confidence threshold for filtering detection results.</li>\n<li><strong>model (onnxruntime.InferenceSession):</strong>  ONNX model inference session.</li>\n<li><strong>input_name (str):</strong>  Name of the input tensor for the ONNX model.</li>\n<li><strong>output_name (str):</strong>  Name of the output tensor for the ONNX model.</li>\n<li><strong>input_shape (list):</strong>  Shape of the input tensor for the ONNX model.</li>\n<li><strong>R_y (numpy.ndarray):</strong>  Rotation matrix for adjusting camera angle.</li>\n<li><strong>class_map (dict):</strong>  Mapping of class IDs to custom class indices.</li>\n</ul>\n\n<h6 id=\"methods\">Methods:</h6>\n\n<blockquote>\n  <p>__init__(model_path, cam_K, depth_K, conf_thresh=0.25, verbose=False):\n      Initializes the OnnxCamera object with the given parameters.\n  detect(image):\n      Performs object detection on the input image using the ONNX model.\n  get_detections(image, depth_image):\n      Detects objects in the input image, calculates their world coordinates, and visualizes results.</p>\n</blockquote>\n"}, {"fullname": "algorithms.camera.OnnxCamera.__init__", "modulename": "algorithms.camera", "qualname": "OnnxCamera.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">model_path</span>, </span><span class=\"param\"><span class=\"n\">cam_K</span>, </span><span class=\"param\"><span class=\"n\">depth_K</span>, </span><span class=\"param\"><span class=\"n\">conf_thresh</span><span class=\"o\">=</span><span class=\"mf\">0.25</span>, </span><span class=\"param\"><span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span>)</span>"}, {"fullname": "algorithms.camera.OnnxCamera.cam_K", "modulename": "algorithms.camera", "qualname": "OnnxCamera.cam_K", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.camera.OnnxCamera.depth_K", "modulename": "algorithms.camera", "qualname": "OnnxCamera.depth_K", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.camera.OnnxCamera.cam_to_depth", "modulename": "algorithms.camera", "qualname": "OnnxCamera.cam_to_depth", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.camera.OnnxCamera.verbose", "modulename": "algorithms.camera", "qualname": "OnnxCamera.verbose", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.camera.OnnxCamera.conf_thresh", "modulename": "algorithms.camera", "qualname": "OnnxCamera.conf_thresh", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.camera.OnnxCamera.model", "modulename": "algorithms.camera", "qualname": "OnnxCamera.model", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.camera.OnnxCamera.input_name", "modulename": "algorithms.camera", "qualname": "OnnxCamera.input_name", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.camera.OnnxCamera.output_name", "modulename": "algorithms.camera", "qualname": "OnnxCamera.output_name", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.camera.OnnxCamera.input_shape", "modulename": "algorithms.camera", "qualname": "OnnxCamera.input_shape", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.camera.OnnxCamera.class_map", "modulename": "algorithms.camera", "qualname": "OnnxCamera.class_map", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.camera.OnnxCamera.detect", "modulename": "algorithms.camera", "qualname": "OnnxCamera.detect", "kind": "function", "doc": "<p>Perform object detection on the given image.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>image (numpy.ndarray):</strong>  The input image in BGR format.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>numpy.ndarray: A 2D array where each row represents a detected object with the following columns:\n      - [0:4]: Bounding box coordinates in the format [x_min, y_min, x_max, y_max].\n      - [4]: Confidence score of the detection.\n      - [5]: Class label of the detected object.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">image</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "algorithms.camera.OnnxCamera.get_detections", "modulename": "algorithms.camera", "qualname": "OnnxCamera.get_detections", "kind": "function", "doc": "<p>Processes an image and its corresponding depth image to detect objects and\ncalculate their world coordinates.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>image (numpy.ndarray):</strong>  The BGR image to process.</li>\n<li><strong>depth_image (numpy.ndarray):</strong>  The depth image corresponding to the RGB image.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>numpy.ndarray: A 2D array where each row represents the world coordinates and class.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">image</span>, </span><span class=\"param\"><span class=\"n\">depth_image</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "algorithms.geometry", "modulename": "algorithms.geometry", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "algorithms.geometry.global_to_local", "modulename": "algorithms.geometry", "qualname": "global_to_local", "kind": "function", "doc": "<p>Convert points from global to local coordinates.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  Points to be converted</li>\n<li><strong>pose (np.ndarray):</strong>  Position of the car in global coordinates (x,y,yaw)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: Converted points</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">points</span>, </span><span class=\"param\"><span class=\"n\">pose</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "algorithms.geometry.local_to_global", "modulename": "algorithms.geometry", "qualname": "local_to_global", "kind": "function", "doc": "<p>Convert points from local to global coordinates.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  Points to be converted</li>\n<li><strong>pose (np.ndarray):</strong>  Position of the car in global coordinates (x,y,yaw)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: Converted points</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">points</span>, </span><span class=\"param\"><span class=\"n\">pose</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "algorithms.geometry.rotate_points", "modulename": "algorithms.geometry", "qualname": "rotate_points", "kind": "function", "doc": "<p>Rotate points around the origin</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  Points to be rotated</li>\n<li><strong>angle (float):</strong>  Angle in radians</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: Rotated points</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">points</span>, </span><span class=\"param\"><span class=\"n\">angle</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "algorithms.odometry", "modulename": "algorithms.odometry", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "algorithms.odometry.Odometry", "modulename": "algorithms.odometry", "qualname": "Odometry", "kind": "class", "doc": "<p>A class to manage and track the odometry of the robot.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>turtle:</strong>  Instance of the turtle_bot class.</li>\n<li><strong>last_odometry:</strong>  The last recorded odometry data of the turtle robot.</li>\n</ul>\n\n<h6 id=\"methods\">Methods:</h6>\n\n<blockquote>\n  <p>__init__(turtle):\n      Initializes the Odometry object with the given turtle robot and stores its initial odometry data.\n  update_and_get_delta():\n      Updates the stored odometry data and returns the previous and current odometry values as a tuple.</p>\n</blockquote>\n"}, {"fullname": "algorithms.odometry.Odometry.__init__", "modulename": "algorithms.odometry", "qualname": "Odometry.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">turtle</span></span>)</span>"}, {"fullname": "algorithms.odometry.Odometry.turtle", "modulename": "algorithms.odometry", "qualname": "Odometry.turtle", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.odometry.Odometry.last_odometry", "modulename": "algorithms.odometry", "qualname": "Odometry.last_odometry", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.odometry.Odometry.update_and_get_delta", "modulename": "algorithms.odometry", "qualname": "Odometry.update_and_get_delta", "kind": "function", "doc": "<p>Updates the stored odometry data and calculates the delta between the\nprevious and current odometry readings.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>tuple: A tuple containing two elements:\n      - odo_old: The previous odometry reading.\n      - odo_new: The current odometry reading.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "algorithms.velocity_control", "modulename": "algorithms.velocity_control", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "algorithms.velocity_control.VelocityControl", "modulename": "algorithms.velocity_control", "qualname": "VelocityControl", "kind": "class", "doc": "<p>A class to control the velocity of the robot, ensuring smooth acceleration\nand deceleration while adhering to specified constraints on speed and angular velocity.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>turtle:</strong>  Instance of the turtle_bot class.</li>\n<li><strong>velocity (float):</strong>  The current linear velocity of the turtle.</li>\n<li><strong>max_acc (float):</strong>  The maximum linear acceleration (m/s^2).</li>\n<li><strong>max_ang_acc (float):</strong>  The maximum angular acceleration (rad/s^2).</li>\n<li><strong>max_speed (float):</strong>  The maximum linear speed (m/s).</li>\n<li><strong>max_ang_speed (float):</strong>  The maximum angular speed (rad/s).</li>\n<li><strong>last_cmd (tuple):</strong>  The last commanded velocity as a tuple (linear, angular).</li>\n<li><strong>ang_p (float):</strong>  The proportional gain for angular velocity control.</li>\n</ul>\n\n<h6 id=\"methods\">Methods:</h6>\n\n<blockquote>\n  <p>cmd_velocity(position, target_position, dt):\n      Computes the linear and angular velocity commands to move the turtle\n      towards a target position while respecting acceleration and speed limits.</p>\n</blockquote>\n"}, {"fullname": "algorithms.velocity_control.VelocityControl.velocity", "modulename": "algorithms.velocity_control", "qualname": "VelocityControl.velocity", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.velocity_control.VelocityControl.max_acc", "modulename": "algorithms.velocity_control", "qualname": "VelocityControl.max_acc", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.velocity_control.VelocityControl.max_speed", "modulename": "algorithms.velocity_control", "qualname": "VelocityControl.max_speed", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.velocity_control.VelocityControl.max_ang_speed", "modulename": "algorithms.velocity_control", "qualname": "VelocityControl.max_ang_speed", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.velocity_control.VelocityControl.last_cmd", "modulename": "algorithms.velocity_control", "qualname": "VelocityControl.last_cmd", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.velocity_control.VelocityControl.ang_p", "modulename": "algorithms.velocity_control", "qualname": "VelocityControl.ang_p", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "algorithms.velocity_control.VelocityControl.cmd_velocity", "modulename": "algorithms.velocity_control", "qualname": "VelocityControl.cmd_velocity", "kind": "function", "doc": "<p>Calculate the linear and angular velocity required to move towards a target position.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>position (numpy.ndarray):</strong>  The current position and orientation of the object\nin the global frame.</li>\n<li><strong>target_position (numpy.ndarray):</strong>  The target position in the global frame.</li>\n<li><strong>dt (float):</strong>  The time step for velocity calculation.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>tuple: A tuple containing:\n      - velocity (float): The linear velocity to move towards the target position.\n      - ang_velocity (float): The angular velocity to rotate towards the target position.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">position</span>, </span><span class=\"param\"><span class=\"n\">target_position</span>, </span><span class=\"param\"><span class=\"n\">dt</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "configs", "modulename": "configs", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "configs.alg_config", "modulename": "configs.alg_config", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "configs.alg_config.slam_config", "modulename": "configs.alg_config", "qualname": "slam_config", "kind": "variable", "doc": "<p></p>\n", "default_value": "{&#x27;pairing_distance&#x27;: 0.6, &#x27;detection_var&#x27;: 0.2, &#x27;position_var&#x27;: 0.02, &#x27;rotation_var&#x27;: 0.001, &#x27;min_occurences&#x27;: 2, &#x27;detection_timeout&#x27;: 1}"}, {"fullname": "configs.alg_config.PlanningParm", "modulename": "configs.alg_config", "qualname": "PlanningParm", "kind": "class", "doc": "<p>PlanningParm is a configuration class.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>CLEARANCE (float):</strong>  Minimum clearance distance required around obstacles.</li>\n<li><strong>SHOOT_SCALING (float):</strong>  Scaling factor for shooting calculations.</li>\n<li><strong>SHOOT_STEPBACK (float):</strong>  Distance to step back before kicking the ball.</li>\n<li><strong>BALL_PROXIMITY (float):</strong>  Proximity threshold to the ball.</li>\n<li><strong>HADING_CHECK (float):</strong>  Heading check threshold in radians.</li>\n<li><strong>ROBOT_TURN_RADIUS (float):</strong>  Turning radius of the robot.</li>\n<li><strong>GOAL_POX (float):</strong>  Proximity threshold to the goal position.</li>\n<li><strong>SHOOT_ALIGNMENT (float):</strong>  Alignment threshold for shooting.</li>\n<li><strong>GOAL_CHECK (float):</strong>  Position of checks points for goal. Behind and in front of the goal line.</li>\n<li><strong>ROBOT_DIST_MIN (float):</strong>  How close to the goal line, can the robot get to.</li>\n</ul>\n"}, {"fullname": "configs.alg_config.PlanningParm.CLEARANCE", "modulename": "configs.alg_config", "qualname": "PlanningParm.CLEARANCE", "kind": "variable", "doc": "<p></p>\n", "default_value": "0.5"}, {"fullname": "configs.alg_config.PlanningParm.SHOOT_SCALING", "modulename": "configs.alg_config", "qualname": "PlanningParm.SHOOT_SCALING", "kind": "variable", "doc": "<p></p>\n", "default_value": "2"}, {"fullname": "configs.alg_config.PlanningParm.SHOOT_STEPBACK", "modulename": "configs.alg_config", "qualname": "PlanningParm.SHOOT_STEPBACK", "kind": "variable", "doc": "<p></p>\n", "default_value": "0.8"}, {"fullname": "configs.alg_config.PlanningParm.BALL_PROXIMITY", "modulename": "configs.alg_config", "qualname": "PlanningParm.BALL_PROXIMITY", "kind": "variable", "doc": "<p></p>\n", "default_value": "0.2"}, {"fullname": "configs.alg_config.PlanningParm.HADING_CHECK", "modulename": "configs.alg_config", "qualname": "PlanningParm.HADING_CHECK", "kind": "variable", "doc": "<p></p>\n", "default_value": "0.1746"}, {"fullname": "configs.alg_config.PlanningParm.ROBOT_TURN_RADIUS", "modulename": "configs.alg_config", "qualname": "PlanningParm.ROBOT_TURN_RADIUS", "kind": "variable", "doc": "<p></p>\n", "default_value": "0.3"}, {"fullname": "configs.alg_config.PlanningParm.GOAL_POX", "modulename": "configs.alg_config", "qualname": "PlanningParm.GOAL_POX", "kind": "variable", "doc": "<p></p>\n", "default_value": "0.7"}, {"fullname": "configs.alg_config.PlanningParm.SHOOT_ALIGNMENT", "modulename": "configs.alg_config", "qualname": "PlanningParm.SHOOT_ALIGNMENT", "kind": "variable", "doc": "<p></p>\n", "default_value": "0.1"}, {"fullname": "configs.alg_config.PlanningParm.GOAL_CHECK", "modulename": "configs.alg_config", "qualname": "PlanningParm.GOAL_CHECK", "kind": "variable", "doc": "<p></p>\n", "default_value": "0.1"}, {"fullname": "configs.alg_config.PlanningParm.ROBOT_DIST_MIN", "modulename": "configs.alg_config", "qualname": "PlanningParm.ROBOT_DIST_MIN", "kind": "variable", "doc": "<p></p>\n", "default_value": "0.48"}, {"fullname": "configs.alg_config.vision_config", "modulename": "configs.alg_config", "qualname": "vision_config", "kind": "variable", "doc": "<p></p>\n", "default_value": "{&#x27;show&#x27;: False, &#x27;cls_to_col&#x27;: {&lt;DataClasses.GREEN: 0&gt;: (0, 255, 0), &lt;DataClasses.RED: 1&gt;: (0, 0, 255), &lt;DataClasses.BLUE: 2&gt;: (255, 0, 0), &lt;DataClasses.BALL: 3&gt;: (0, 255, 255)}, &#x27;class_map&#x27;: {0: &lt;DataClasses.BALL: 3&gt;, 1: &lt;DataClasses.BALL: 3&gt;, 2: &lt;DataClasses.BLUE: 2&gt;, 3: &lt;DataClasses.GREEN: 0&gt;, 4: &lt;DataClasses.RED: 1&gt;}}"}, {"fullname": "configs.alg_config.velocity_control_config", "modulename": "configs.alg_config", "qualname": "velocity_control_config", "kind": "variable", "doc": "<p></p>\n", "default_value": "{&#x27;max_acc&#x27;: 0.8, &#x27;max_speed&#x27;: 0.8, &#x27;max_ang_speed&#x27;: 0.8, &#x27;ang_p&#x27;: 1.5}"}, {"fullname": "configs.value_enums", "modulename": "configs.value_enums", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "configs.value_enums.DataClasses", "modulename": "configs.value_enums", "qualname": "DataClasses", "kind": "class", "doc": "<p>Enum for data classes</p>\n", "bases": "enum.IntEnum"}, {"fullname": "configs.value_enums.DataClasses.GREEN", "modulename": "configs.value_enums", "qualname": "DataClasses.GREEN", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;DataClasses.GREEN: 0&gt;"}, {"fullname": "configs.value_enums.DataClasses.RED", "modulename": "configs.value_enums", "qualname": "DataClasses.RED", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;DataClasses.RED: 1&gt;"}, {"fullname": "configs.value_enums.DataClasses.BLUE", "modulename": "configs.value_enums", "qualname": "DataClasses.BLUE", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;DataClasses.BLUE: 2&gt;"}, {"fullname": "configs.value_enums.DataClasses.BALL", "modulename": "configs.value_enums", "qualname": "DataClasses.BALL", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;DataClasses.BALL: 3&gt;"}, {"fullname": "configs.value_enums.ErrorCodes", "modulename": "configs.value_enums", "qualname": "ErrorCodes", "kind": "class", "doc": "<p>Enum for data classed.</p>\n", "bases": "enum.IntEnum"}, {"fullname": "configs.value_enums.ErrorCodes.OK_ERR", "modulename": "configs.value_enums", "qualname": "ErrorCodes.OK_ERR", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ErrorCodes.OK_ERR: 0&gt;"}, {"fullname": "configs.value_enums.ErrorCodes.MORE_BLUE_ERR", "modulename": "configs.value_enums", "qualname": "ErrorCodes.MORE_BLUE_ERR", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ErrorCodes.MORE_BLUE_ERR: 1&gt;"}, {"fullname": "configs.value_enums.ErrorCodes.NO_BALL_ERR", "modulename": "configs.value_enums", "qualname": "ErrorCodes.NO_BALL_ERR", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ErrorCodes.NO_BALL_ERR: 2&gt;"}, {"fullname": "configs.value_enums.ErrorCodes.BALL_STUCK_ERR", "modulename": "configs.value_enums", "qualname": "ErrorCodes.BALL_STUCK_ERR", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ErrorCodes.BALL_STUCK_ERR: 3&gt;"}, {"fullname": "configs.value_enums.ErrorCodes.NO_SHOOT_ERR", "modulename": "configs.value_enums", "qualname": "ErrorCodes.NO_SHOOT_ERR", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ErrorCodes.NO_SHOOT_ERR: 4&gt;"}, {"fullname": "configs.value_enums.ErrorCodes.NO_ROBOT_ERR", "modulename": "configs.value_enums", "qualname": "ErrorCodes.NO_ROBOT_ERR", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ErrorCodes.NO_ROBOT_ERR: 5&gt;"}, {"fullname": "configs.value_enums.ErrorCodes.ZERO_BLUE_ERR", "modulename": "configs.value_enums", "qualname": "ErrorCodes.ZERO_BLUE_ERR", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ErrorCodes.ZERO_BLUE_ERR: 6&gt;"}, {"fullname": "configs.value_enums.ErrorCodes.IS_GOAL_ERR", "modulename": "configs.value_enums", "qualname": "ErrorCodes.IS_GOAL_ERR", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ErrorCodes.IS_GOAL_ERR: 7&gt;"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();