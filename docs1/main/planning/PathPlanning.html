<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>main.planning.PathPlanning API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>main.planning.PathPlanning</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="main.planning.PathPlanning.Planning"><code class="flex name class">
<span>class <span class="ident">Planning</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Planning:
    def __init__(self):
        self.objects = {}
        for type_ in DataClasses:
            self.objects[type_] = []
        self.goal_targer = None
        self.ball_pos = None
        self.ball_path = None
        self.robot_pos = None
        self.time_to_shoot = False

    def create_path(self, object_pos, robot_pos, test_alg=False):
        &#34;&#34;&#34;
        Returns next point in a path or robot path and ball path if test_alg is true
        &#34;&#34;&#34;

        next_point = None
        # Objects identification
        self.clear_objects()
        self.robot_pos = robot_pos
        inden_outcome = self.identify_objects(object_pos)
        if inden_outcome == ErrorCodes.IS_GOAL_ERR:
            self.time_to_shoot = False
            if test_alg:
                return None, None, None  # Returns None if the ball is in the goal
            next_point = None
        elif inden_outcome == ErrorCodes.NO_BALL_ERR or inden_outcome == ErrorCodes.ZERO_BLUE_ERR:
            print(&#34;No ball or no blue tube&#34;)
            next_point = self.turn_robot_around(self.robot_pos[:2], self.robot_pos[2], PlanningParm.ROBOT_TURN_RADIUS)
            if test_alg:
                return np.array([self.robot_pos[:2], next_point]), np.empty((0, 2)), np.empty((0, 2))  # Returns only point for rotation
            return next_point
        else:
            self.ball_path = self.generate_trajectory(self.ball_pos, self.goal_targer)  # Generates a path for the ball to the goal targer
            if self.ball_path is None:
                return ErrorCodes.BALL_STUCK_ERR

            shoot_path = self.generate_shoot_path()  # Generates a shooting point for the robot and path to the ball
            if shoot_path is None:
                return ErrorCodes.NO_SHOOT_ERR

            robot_destination = None
            hading_v = shoot_path[1] - shoot_path[0]
            if self.are_points_in_proximity(self.robot_pos[:2], shoot_path[0] + PlanningParm.SHOOT_ALIGNMENT * hading_v) and self.same_hading(hading_v, self.robot_pos[2]):
                print(&#34;Time to shoot&#34;)
                robot_destination = shoot_path[1]
                self.time_to_shoot = True
            elif self.are_points_in_proximity(self.robot_pos[:2], shoot_path[0] + PlanningParm.SHOOT_ALIGNMENT * hading_v):
                print(&#34;Time to turn&#34;)
                robot_destination = self.turn_robot_around(self.robot_pos[:2], self.robot_pos[2], PlanningParm.ROBOT_TURN_RADIUS)
                self.time_to_shoot = True
            elif self.are_points_in_proximity(self.robot_pos[:2], shoot_path[0]):
                print(&#34;Time to turn point&#34;)
                robot_destination = shoot_path[0] + PlanningParm.SHOOT_ALIGNMENT * hading_v
                self.time_to_shoot = True
            elif self.are_points_in_proximity(self.robot_pos[:2], self.ball_pos, PlanningParm.BALL_PROXIMITY):
                self.time_to_shoot = False
                robot_destination = self.robot_pos[:2]
            else:
                print(&#34;Time to move&#34;)
                self.time_to_shoot = False
                robot_destination = shoot_path[0]

            robot_path_to_shoot = self.generate_trajectory(self.robot_pos[:2], robot_destination)  # Generates a path for the robot to the shooting point
            if robot_path_to_shoot is None:
                return ErrorCodes.NO_ROBOT_ERR

            if test_alg:
                return robot_path_to_shoot, shoot_path, self.ball_path  # Returns all paths for testing
            next_point = robot_path_to_shoot[1]  # Sets the next point for the robot to follow

        return next_point  # Returns the next point in the path for the robot to follow

    def clear_objects(self):
        &#34;&#34;&#34;
        Clears all objectss
        &#34;&#34;&#34;

        for type_ in DataClasses:
            self.objects[type_] = []

    def same_hading(self, vector, angle):
        &#34;&#34;&#34;
        Checks if the robot is in the same direction as the vector
        &#34;&#34;&#34;

        aplha = np.arctan2(vector[1], vector[0])
        if np.abs(aplha - angle) &lt; PlanningParm.HADING_CHECK:
            return True
        return False

    def turn_robot_around(self, center, angle, distance):
        &#34;&#34;&#34;
        Turns the robot around by -90 degrees
        &#34;&#34;&#34;

        vector = np.array([distance * np.cos(angle), distance * np.sin(angle)])
        vector = self.mat_rot(-np.pi / 2, vector)
        vector = vector / np.linalg.norm(vector) * distance
        return center + vector

    def identify_objects(self, objects_in):
        &#34;&#34;&#34;
        Indenfify objects and add them to the objects list
        &#34;&#34;&#34;

        center_sum = np.array([0, 0])
        blue_count = 0
        poss_balls = np.empty((0, 2))

        for object in objects_in:
            self.objects[object[2]].append(object)
            if object[2] == DataClasses.BLUE:
                blue_count += 1
                center_sum = center_sum + np.array(object[0:2])
            elif object[2] == DataClasses.BALL:
                poss_balls = np.vstack([poss_balls, np.array(object[0:2])])

        if poss_balls.size != 0:
            self.ball_pos = np.mean(poss_balls, axis=0)  # Calculates the mean of all ball positions if the possition is not sure
        if self.ball_pos is None:
            return ErrorCodes.NO_BALL_ERR

        if blue_count &gt; 2:
            self.goal_targer = self.solve_more_blue_tubes()
        elif blue_count == 2:
            self.goal_targer = center_sum / 2  # Calculates the center of the goal
            if self.is_goal():
                return ErrorCodes.IS_GOAL_ERR
        elif blue_count == 1 and self.goal_targer is not None:
            return ErrorCodes.ZERO_BLUE_ERR
            if self.are_points_in_proximity(self.goal_targer, center_sum, PlanningParm.GOAL_POX):
                self.goal_targer = self.goal_targer  # Sets a position of the blue tube as a goal target
            else:
                self.goal_targer = center_sum
        elif blue_count == 1:
            return ErrorCodes.ZERO_BLUE_ERR
            self.goal_targer = center_sum
        else:
            if self.goal_targer is None:
                return ErrorCodes.ZERO_BLUE_ERR
            else:
                # check if is goal
                return ErrorCodes.OK_ERR
        return ErrorCodes.OK_ERR

    def solve_more_blue_tubes(self):
        &#34;&#34;&#34;
        Solves the problem of more than 2 blue tubes by returning the first blue tube or the goal target if it exists
        &#34;&#34;&#34;

        blue_tubes = self.objects[DataClasses.BLUE]
        if self.goal_targer is None:
            return blue_tubes[0]
        return self.goal_targer

    def is_goal(self):
        &#34;&#34;&#34;
        Checks if the ball is in the goal
        &#34;&#34;&#34;

        if self.ball_pos is not None and self.goal_targer is not None:
            # vec_behind = self.goal_targer - self.objects[DataClasses.BLUE][0][0:2]
            # ver_beh_rot = self.mat_rot(-np.pi/2, vec_behind)
            blue_vec = self.objects[DataClasses.BLUE][1][0:2] - self.objects[DataClasses.BLUE][0][0:2]
            t = np.dot(self.robot_pos[:2] - self.objects[DataClasses.BLUE][0][0:2], blue_vec) / np.linalg.norm(blue_vec) ** 2
            t = np.clip(t, 0, 1)
            robot_dist = np.linalg.norm(self.robot_pos[:2] - (self.objects[DataClasses.BLUE][0][0:2] + t * blue_vec))
            behind_goal = self.goal_targer - self.robot_pos[:2]
            projection = (np.dot(blue_vec, behind_goal) / np.dot(blue_vec, blue_vec)) * blue_vec
            behind_goal = behind_goal - projection
            behind_goal = (behind_goal / np.linalg.norm(behind_goal) * PlanningParm.GOAL_CHECK)
            dis_to_target = np.linalg.norm(self.ball_pos - (self.goal_targer - behind_goal))
            dis_to_check = np.linalg.norm(self.ball_pos - (self.goal_targer + behind_goal))
            if dis_to_target &gt; dis_to_check or robot_dist &lt; PlanningParm.ROBOT_DIST_MIN:
                return True
        return False

    def generate_trajectory(self, start, target):
        &#34;&#34;&#34;
        Gernerates a path from start to target point and avoids one obstacle point
        &#34;&#34;&#34;

        path_points = None
        problem_point = self.check_colisions(np.array([start, target]))  # Checks for colision of a direct path between start and target

        if problem_point is not None:
            path_points = self.generate_way_around(start, target, problem_point)  # Generates a path around the problematic point
        else:
            path_points = np.array([start, target])  # Creates direct path to the target

        return path_points

    def generate_way_around(self, start, end, problem):
        &#34;&#34;&#34;
        Generates a path around the problem point by finding the shortest path through the tangent points.
        &#34;&#34;&#34;

        if np.linalg.norm(start - problem) &lt; PlanningParm.CLEARANCE or np.linalg.norm(end - problem) &lt; PlanningParm.CLEARANCE:
            return np.array([start, end])

        # Finds the tangent points from the start and end points to the problem point
        tangent_point1, tangent_point2 = self.find_tangent_points(start, problem, PlanningParm.CLEARANCE)
        tangent_point3, tangent_point4 = self.find_tangent_points(end, problem, PlanningParm.CLEARANCE)

        # Creates a list of all possible combinations of tangent points
        combinations = [(tangent_point1, tangent_point3), (tangent_point1, tangent_point4), (tangent_point2, tangent_point3), (tangent_point2, tangent_point4)]

        shortest_inter, min_distance = None, float(&#39;inf&#39;)
        for tangent_point_A, tangent_point_B in combinations:
            intersection = self.find_intersection(start, tangent_point_A, end, tangent_point_B)  # finds the intersection point of the two tangent lines
            distance = self.path_length([start, intersection, end])
            if distance &lt; min_distance:
                min_distance = distance
                shortest_inter = intersection

        return np.array([start, shortest_inter, end])

    def generate_shoot_path(self):
        &#34;&#34;&#34;
        Generates a shooting point for the robot and a path to the ball
        &#34;&#34;&#34;

        ball_point = self.ball_path[0]
        end_point = self.ball_path[1]
        direction = end_point - ball_point
        norm_direction = direction / np.linalg.norm(direction)
        shooting_point = ball_point - norm_direction * PlanningParm.SHOOT_STEPBACK  # Calculates the shooting point by moving back from the ball point
        overshoot_point = ball_point + norm_direction * PlanningParm.SHOOT_SCALING  # Calculates the overshoot point to gain speed

        return np.array([shooting_point, overshoot_point])

    def check_colisions(self, path):
        &#34;&#34;&#34;
        Checks if there are any collisions with the path between the start and end points and returns the collision point if there is one.
        &#34;&#34;&#34;

        colision_point = None
        for data_class in DataClasses:
            if data_class == DataClasses.BLUE:
                continue
            elif data_class == DataClasses.BALL and self.time_to_shoot:
                continue
            else:
                colision = self.check_colision_from_class(path, data_class)
                if colision is not None:
                    colision_point = colision
                    break

        return colision_point

    def check_colision_from_class(self, path, data_class):
        &#34;&#34;&#34;
        Checks for colision with specified class of objects and returns the colision point if there is one.
        &#34;&#34;&#34;

        colision = None
        for tube in self.objects[data_class]:  # Checks for colision with all green tubes
            tube_pos = np.array(tube[0:2])
            distance = self.point_distance_from_line(tube_pos, path[0], path[1])  # Calculates the distance from the line to the tube
            if distance &lt; PlanningParm.CLEARANCE:
                colision = tube_pos
                break
        return colision

    def point_distance_from_line(self, P, A, B):
        &#34;&#34;&#34;
        Calculates the perpendicular distance of a point from the line defined by points A and B.
        &#34;&#34;&#34;

        AB = B - A
        AP = P - A

        # Projecton of AP onto AB
        AB_dot_AB = np.dot(AB, AB)
        AP_dot_AB = np.dot(AP, AB)

        t = AP_dot_AB / AB_dot_AB

        # If t is outside the segment, return the distance to the nearest endpoint
        if t &lt; 0.0:
            nearest_point = A
        elif t &gt; 1.0:
            nearest_point = B
        else:
            nearest_point = A + t * AB

        return np.linalg.norm(P - nearest_point)

    def find_tangent_points(self, start, center, radius):
        &#34;&#34;&#34;
        Finds two tangent points from start point to circle.
        &#34;&#34;&#34;

        d = start - center
        d_norm = np.linalg.norm(d)
        angle = np.arccos(radius / d_norm)
        d_unit = d / d_norm

        dir1 = self.mat_rot(angle, d_unit)
        dir2 = self.mat_rot(-angle, d_unit)
        tangent_point1 = center + radius * dir1
        tangent_point2 = center + radius * dir2

        return tangent_point1, tangent_point2

    def mat_rot(self, angle, vector):
        &#34;&#34;&#34;
        Returns a rotation matrix for a given angle
        &#34;&#34;&#34;

        mat = np.array([[np.cos(angle), -np.sin(angle)], [np.sin(angle), np.cos(angle)]])
        rotated_vector = np.dot(mat, vector)
        return rotated_vector

    def path_length(self, points):
        &#34;&#34;&#34;
        Calculates the total length of a line.
        &#34;&#34;&#34;

        return np.sum(np.linalg.norm(np.diff(points, axis=0), axis=1))

    def find_intersection(self, lineA_a, lineA_b, lineB_a, lineB_b):
        &#34;&#34;&#34;
        Finds the intersection point of two lines defined by two points each.
        1. lineA: (lineA_a, lineA_b)
        2. lineB: (lineB_a, lineB_b)
        3. Returns the intersection point if exists, else None
        &#34;&#34;&#34;

        lineA = lineA_b - lineA_a
        lineB = lineB_b - lineB_a
        M = np.column_stack([lineA, -lineB])
        rhs = lineB_a - lineA_a

        if np.linalg.det(M) == 0:
            return None  # Lines are parallel and do not intersect

        t, s = np.linalg.solve(M, rhs)
        intersection = lineA_a + t * lineA
        return intersection

    def are_points_in_proximity(self, point1, point2, dis_check=PlanningParm.BALL_PROXIMITY):
        &#34;&#34;&#34;
        Checks if two points are within a given proximity.
        &#34;&#34;&#34;
        state = False
        distance = np.linalg.norm(np.array(point1) - np.array(point2))
        if distance &lt; dis_check:
            state = True
        return state</code></pre>
</details>
<div class="desc"></div>
<h3>Methods</h3>
<dl>
<dt id="main.planning.PathPlanning.Planning.are_points_in_proximity"><code class="name flex">
<span>def <span class="ident">are_points_in_proximity</span></span>(<span>self, point1, point2, dis_check=0.2)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def are_points_in_proximity(self, point1, point2, dis_check=PlanningParm.BALL_PROXIMITY):
    &#34;&#34;&#34;
    Checks if two points are within a given proximity.
    &#34;&#34;&#34;
    state = False
    distance = np.linalg.norm(np.array(point1) - np.array(point2))
    if distance &lt; dis_check:
        state = True
    return state</code></pre>
</details>
<div class="desc"><p>Checks if two points are within a given proximity.</p></div>
</dd>
<dt id="main.planning.PathPlanning.Planning.check_colision_from_class"><code class="name flex">
<span>def <span class="ident">check_colision_from_class</span></span>(<span>self, path, data_class)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_colision_from_class(self, path, data_class):
    &#34;&#34;&#34;
    Checks for colision with specified class of objects and returns the colision point if there is one.
    &#34;&#34;&#34;

    colision = None
    for tube in self.objects[data_class]:  # Checks for colision with all green tubes
        tube_pos = np.array(tube[0:2])
        distance = self.point_distance_from_line(tube_pos, path[0], path[1])  # Calculates the distance from the line to the tube
        if distance &lt; PlanningParm.CLEARANCE:
            colision = tube_pos
            break
    return colision</code></pre>
</details>
<div class="desc"><p>Checks for colision with specified class of objects and returns the colision point if there is one.</p></div>
</dd>
<dt id="main.planning.PathPlanning.Planning.check_colisions"><code class="name flex">
<span>def <span class="ident">check_colisions</span></span>(<span>self, path)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_colisions(self, path):
    &#34;&#34;&#34;
    Checks if there are any collisions with the path between the start and end points and returns the collision point if there is one.
    &#34;&#34;&#34;

    colision_point = None
    for data_class in DataClasses:
        if data_class == DataClasses.BLUE:
            continue
        elif data_class == DataClasses.BALL and self.time_to_shoot:
            continue
        else:
            colision = self.check_colision_from_class(path, data_class)
            if colision is not None:
                colision_point = colision
                break

    return colision_point</code></pre>
</details>
<div class="desc"><p>Checks if there are any collisions with the path between the start and end points and returns the collision point if there is one.</p></div>
</dd>
<dt id="main.planning.PathPlanning.Planning.clear_objects"><code class="name flex">
<span>def <span class="ident">clear_objects</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_objects(self):
    &#34;&#34;&#34;
    Clears all objectss
    &#34;&#34;&#34;

    for type_ in DataClasses:
        self.objects[type_] = []</code></pre>
</details>
<div class="desc"><p>Clears all objectss</p></div>
</dd>
<dt id="main.planning.PathPlanning.Planning.create_path"><code class="name flex">
<span>def <span class="ident">create_path</span></span>(<span>self, object_pos, robot_pos, test_alg=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_path(self, object_pos, robot_pos, test_alg=False):
    &#34;&#34;&#34;
    Returns next point in a path or robot path and ball path if test_alg is true
    &#34;&#34;&#34;

    next_point = None
    # Objects identification
    self.clear_objects()
    self.robot_pos = robot_pos
    inden_outcome = self.identify_objects(object_pos)
    if inden_outcome == ErrorCodes.IS_GOAL_ERR:
        self.time_to_shoot = False
        if test_alg:
            return None, None, None  # Returns None if the ball is in the goal
        next_point = None
    elif inden_outcome == ErrorCodes.NO_BALL_ERR or inden_outcome == ErrorCodes.ZERO_BLUE_ERR:
        print(&#34;No ball or no blue tube&#34;)
        next_point = self.turn_robot_around(self.robot_pos[:2], self.robot_pos[2], PlanningParm.ROBOT_TURN_RADIUS)
        if test_alg:
            return np.array([self.robot_pos[:2], next_point]), np.empty((0, 2)), np.empty((0, 2))  # Returns only point for rotation
        return next_point
    else:
        self.ball_path = self.generate_trajectory(self.ball_pos, self.goal_targer)  # Generates a path for the ball to the goal targer
        if self.ball_path is None:
            return ErrorCodes.BALL_STUCK_ERR

        shoot_path = self.generate_shoot_path()  # Generates a shooting point for the robot and path to the ball
        if shoot_path is None:
            return ErrorCodes.NO_SHOOT_ERR

        robot_destination = None
        hading_v = shoot_path[1] - shoot_path[0]
        if self.are_points_in_proximity(self.robot_pos[:2], shoot_path[0] + PlanningParm.SHOOT_ALIGNMENT * hading_v) and self.same_hading(hading_v, self.robot_pos[2]):
            print(&#34;Time to shoot&#34;)
            robot_destination = shoot_path[1]
            self.time_to_shoot = True
        elif self.are_points_in_proximity(self.robot_pos[:2], shoot_path[0] + PlanningParm.SHOOT_ALIGNMENT * hading_v):
            print(&#34;Time to turn&#34;)
            robot_destination = self.turn_robot_around(self.robot_pos[:2], self.robot_pos[2], PlanningParm.ROBOT_TURN_RADIUS)
            self.time_to_shoot = True
        elif self.are_points_in_proximity(self.robot_pos[:2], shoot_path[0]):
            print(&#34;Time to turn point&#34;)
            robot_destination = shoot_path[0] + PlanningParm.SHOOT_ALIGNMENT * hading_v
            self.time_to_shoot = True
        elif self.are_points_in_proximity(self.robot_pos[:2], self.ball_pos, PlanningParm.BALL_PROXIMITY):
            self.time_to_shoot = False
            robot_destination = self.robot_pos[:2]
        else:
            print(&#34;Time to move&#34;)
            self.time_to_shoot = False
            robot_destination = shoot_path[0]

        robot_path_to_shoot = self.generate_trajectory(self.robot_pos[:2], robot_destination)  # Generates a path for the robot to the shooting point
        if robot_path_to_shoot is None:
            return ErrorCodes.NO_ROBOT_ERR

        if test_alg:
            return robot_path_to_shoot, shoot_path, self.ball_path  # Returns all paths for testing
        next_point = robot_path_to_shoot[1]  # Sets the next point for the robot to follow

    return next_point  # Returns the next point in the path for the robot to follow</code></pre>
</details>
<div class="desc"><p>Returns next point in a path or robot path and ball path if test_alg is true</p></div>
</dd>
<dt id="main.planning.PathPlanning.Planning.find_intersection"><code class="name flex">
<span>def <span class="ident">find_intersection</span></span>(<span>self, lineA_a, lineA_b, lineB_a, lineB_b)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_intersection(self, lineA_a, lineA_b, lineB_a, lineB_b):
    &#34;&#34;&#34;
    Finds the intersection point of two lines defined by two points each.
    1. lineA: (lineA_a, lineA_b)
    2. lineB: (lineB_a, lineB_b)
    3. Returns the intersection point if exists, else None
    &#34;&#34;&#34;

    lineA = lineA_b - lineA_a
    lineB = lineB_b - lineB_a
    M = np.column_stack([lineA, -lineB])
    rhs = lineB_a - lineA_a

    if np.linalg.det(M) == 0:
        return None  # Lines are parallel and do not intersect

    t, s = np.linalg.solve(M, rhs)
    intersection = lineA_a + t * lineA
    return intersection</code></pre>
</details>
<div class="desc"><p>Finds the intersection point of two lines defined by two points each.
1. lineA: (lineA_a, lineA_b)
2. lineB: (lineB_a, lineB_b)
3. Returns the intersection point if exists, else None</p></div>
</dd>
<dt id="main.planning.PathPlanning.Planning.find_tangent_points"><code class="name flex">
<span>def <span class="ident">find_tangent_points</span></span>(<span>self, start, center, radius)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_tangent_points(self, start, center, radius):
    &#34;&#34;&#34;
    Finds two tangent points from start point to circle.
    &#34;&#34;&#34;

    d = start - center
    d_norm = np.linalg.norm(d)
    angle = np.arccos(radius / d_norm)
    d_unit = d / d_norm

    dir1 = self.mat_rot(angle, d_unit)
    dir2 = self.mat_rot(-angle, d_unit)
    tangent_point1 = center + radius * dir1
    tangent_point2 = center + radius * dir2

    return tangent_point1, tangent_point2</code></pre>
</details>
<div class="desc"><p>Finds two tangent points from start point to circle.</p></div>
</dd>
<dt id="main.planning.PathPlanning.Planning.generate_shoot_path"><code class="name flex">
<span>def <span class="ident">generate_shoot_path</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_shoot_path(self):
    &#34;&#34;&#34;
    Generates a shooting point for the robot and a path to the ball
    &#34;&#34;&#34;

    ball_point = self.ball_path[0]
    end_point = self.ball_path[1]
    direction = end_point - ball_point
    norm_direction = direction / np.linalg.norm(direction)
    shooting_point = ball_point - norm_direction * PlanningParm.SHOOT_STEPBACK  # Calculates the shooting point by moving back from the ball point
    overshoot_point = ball_point + norm_direction * PlanningParm.SHOOT_SCALING  # Calculates the overshoot point to gain speed

    return np.array([shooting_point, overshoot_point])</code></pre>
</details>
<div class="desc"><p>Generates a shooting point for the robot and a path to the ball</p></div>
</dd>
<dt id="main.planning.PathPlanning.Planning.generate_trajectory"><code class="name flex">
<span>def <span class="ident">generate_trajectory</span></span>(<span>self, start, target)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_trajectory(self, start, target):
    &#34;&#34;&#34;
    Gernerates a path from start to target point and avoids one obstacle point
    &#34;&#34;&#34;

    path_points = None
    problem_point = self.check_colisions(np.array([start, target]))  # Checks for colision of a direct path between start and target

    if problem_point is not None:
        path_points = self.generate_way_around(start, target, problem_point)  # Generates a path around the problematic point
    else:
        path_points = np.array([start, target])  # Creates direct path to the target

    return path_points</code></pre>
</details>
<div class="desc"><p>Gernerates a path from start to target point and avoids one obstacle point</p></div>
</dd>
<dt id="main.planning.PathPlanning.Planning.generate_way_around"><code class="name flex">
<span>def <span class="ident">generate_way_around</span></span>(<span>self, start, end, problem)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_way_around(self, start, end, problem):
    &#34;&#34;&#34;
    Generates a path around the problem point by finding the shortest path through the tangent points.
    &#34;&#34;&#34;

    if np.linalg.norm(start - problem) &lt; PlanningParm.CLEARANCE or np.linalg.norm(end - problem) &lt; PlanningParm.CLEARANCE:
        return np.array([start, end])

    # Finds the tangent points from the start and end points to the problem point
    tangent_point1, tangent_point2 = self.find_tangent_points(start, problem, PlanningParm.CLEARANCE)
    tangent_point3, tangent_point4 = self.find_tangent_points(end, problem, PlanningParm.CLEARANCE)

    # Creates a list of all possible combinations of tangent points
    combinations = [(tangent_point1, tangent_point3), (tangent_point1, tangent_point4), (tangent_point2, tangent_point3), (tangent_point2, tangent_point4)]

    shortest_inter, min_distance = None, float(&#39;inf&#39;)
    for tangent_point_A, tangent_point_B in combinations:
        intersection = self.find_intersection(start, tangent_point_A, end, tangent_point_B)  # finds the intersection point of the two tangent lines
        distance = self.path_length([start, intersection, end])
        if distance &lt; min_distance:
            min_distance = distance
            shortest_inter = intersection

    return np.array([start, shortest_inter, end])</code></pre>
</details>
<div class="desc"><p>Generates a path around the problem point by finding the shortest path through the tangent points.</p></div>
</dd>
<dt id="main.planning.PathPlanning.Planning.identify_objects"><code class="name flex">
<span>def <span class="ident">identify_objects</span></span>(<span>self, objects_in)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def identify_objects(self, objects_in):
    &#34;&#34;&#34;
    Indenfify objects and add them to the objects list
    &#34;&#34;&#34;

    center_sum = np.array([0, 0])
    blue_count = 0
    poss_balls = np.empty((0, 2))

    for object in objects_in:
        self.objects[object[2]].append(object)
        if object[2] == DataClasses.BLUE:
            blue_count += 1
            center_sum = center_sum + np.array(object[0:2])
        elif object[2] == DataClasses.BALL:
            poss_balls = np.vstack([poss_balls, np.array(object[0:2])])

    if poss_balls.size != 0:
        self.ball_pos = np.mean(poss_balls, axis=0)  # Calculates the mean of all ball positions if the possition is not sure
    if self.ball_pos is None:
        return ErrorCodes.NO_BALL_ERR

    if blue_count &gt; 2:
        self.goal_targer = self.solve_more_blue_tubes()
    elif blue_count == 2:
        self.goal_targer = center_sum / 2  # Calculates the center of the goal
        if self.is_goal():
            return ErrorCodes.IS_GOAL_ERR
    elif blue_count == 1 and self.goal_targer is not None:
        return ErrorCodes.ZERO_BLUE_ERR
        if self.are_points_in_proximity(self.goal_targer, center_sum, PlanningParm.GOAL_POX):
            self.goal_targer = self.goal_targer  # Sets a position of the blue tube as a goal target
        else:
            self.goal_targer = center_sum
    elif blue_count == 1:
        return ErrorCodes.ZERO_BLUE_ERR
        self.goal_targer = center_sum
    else:
        if self.goal_targer is None:
            return ErrorCodes.ZERO_BLUE_ERR
        else:
            # check if is goal
            return ErrorCodes.OK_ERR
    return ErrorCodes.OK_ERR</code></pre>
</details>
<div class="desc"><p>Indenfify objects and add them to the objects list</p></div>
</dd>
<dt id="main.planning.PathPlanning.Planning.is_goal"><code class="name flex">
<span>def <span class="ident">is_goal</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_goal(self):
    &#34;&#34;&#34;
    Checks if the ball is in the goal
    &#34;&#34;&#34;

    if self.ball_pos is not None and self.goal_targer is not None:
        # vec_behind = self.goal_targer - self.objects[DataClasses.BLUE][0][0:2]
        # ver_beh_rot = self.mat_rot(-np.pi/2, vec_behind)
        blue_vec = self.objects[DataClasses.BLUE][1][0:2] - self.objects[DataClasses.BLUE][0][0:2]
        t = np.dot(self.robot_pos[:2] - self.objects[DataClasses.BLUE][0][0:2], blue_vec) / np.linalg.norm(blue_vec) ** 2
        t = np.clip(t, 0, 1)
        robot_dist = np.linalg.norm(self.robot_pos[:2] - (self.objects[DataClasses.BLUE][0][0:2] + t * blue_vec))
        behind_goal = self.goal_targer - self.robot_pos[:2]
        projection = (np.dot(blue_vec, behind_goal) / np.dot(blue_vec, blue_vec)) * blue_vec
        behind_goal = behind_goal - projection
        behind_goal = (behind_goal / np.linalg.norm(behind_goal) * PlanningParm.GOAL_CHECK)
        dis_to_target = np.linalg.norm(self.ball_pos - (self.goal_targer - behind_goal))
        dis_to_check = np.linalg.norm(self.ball_pos - (self.goal_targer + behind_goal))
        if dis_to_target &gt; dis_to_check or robot_dist &lt; PlanningParm.ROBOT_DIST_MIN:
            return True
    return False</code></pre>
</details>
<div class="desc"><p>Checks if the ball is in the goal</p></div>
</dd>
<dt id="main.planning.PathPlanning.Planning.mat_rot"><code class="name flex">
<span>def <span class="ident">mat_rot</span></span>(<span>self, angle, vector)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mat_rot(self, angle, vector):
    &#34;&#34;&#34;
    Returns a rotation matrix for a given angle
    &#34;&#34;&#34;

    mat = np.array([[np.cos(angle), -np.sin(angle)], [np.sin(angle), np.cos(angle)]])
    rotated_vector = np.dot(mat, vector)
    return rotated_vector</code></pre>
</details>
<div class="desc"><p>Returns a rotation matrix for a given angle</p></div>
</dd>
<dt id="main.planning.PathPlanning.Planning.path_length"><code class="name flex">
<span>def <span class="ident">path_length</span></span>(<span>self, points)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def path_length(self, points):
    &#34;&#34;&#34;
    Calculates the total length of a line.
    &#34;&#34;&#34;

    return np.sum(np.linalg.norm(np.diff(points, axis=0), axis=1))</code></pre>
</details>
<div class="desc"><p>Calculates the total length of a line.</p></div>
</dd>
<dt id="main.planning.PathPlanning.Planning.point_distance_from_line"><code class="name flex">
<span>def <span class="ident">point_distance_from_line</span></span>(<span>self, P, A, B)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def point_distance_from_line(self, P, A, B):
    &#34;&#34;&#34;
    Calculates the perpendicular distance of a point from the line defined by points A and B.
    &#34;&#34;&#34;

    AB = B - A
    AP = P - A

    # Projecton of AP onto AB
    AB_dot_AB = np.dot(AB, AB)
    AP_dot_AB = np.dot(AP, AB)

    t = AP_dot_AB / AB_dot_AB

    # If t is outside the segment, return the distance to the nearest endpoint
    if t &lt; 0.0:
        nearest_point = A
    elif t &gt; 1.0:
        nearest_point = B
    else:
        nearest_point = A + t * AB

    return np.linalg.norm(P - nearest_point)</code></pre>
</details>
<div class="desc"><p>Calculates the perpendicular distance of a point from the line defined by points A and B.</p></div>
</dd>
<dt id="main.planning.PathPlanning.Planning.same_hading"><code class="name flex">
<span>def <span class="ident">same_hading</span></span>(<span>self, vector, angle)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def same_hading(self, vector, angle):
    &#34;&#34;&#34;
    Checks if the robot is in the same direction as the vector
    &#34;&#34;&#34;

    aplha = np.arctan2(vector[1], vector[0])
    if np.abs(aplha - angle) &lt; PlanningParm.HADING_CHECK:
        return True
    return False</code></pre>
</details>
<div class="desc"><p>Checks if the robot is in the same direction as the vector</p></div>
</dd>
<dt id="main.planning.PathPlanning.Planning.solve_more_blue_tubes"><code class="name flex">
<span>def <span class="ident">solve_more_blue_tubes</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def solve_more_blue_tubes(self):
    &#34;&#34;&#34;
    Solves the problem of more than 2 blue tubes by returning the first blue tube or the goal target if it exists
    &#34;&#34;&#34;

    blue_tubes = self.objects[DataClasses.BLUE]
    if self.goal_targer is None:
        return blue_tubes[0]
    return self.goal_targer</code></pre>
</details>
<div class="desc"><p>Solves the problem of more than 2 blue tubes by returning the first blue tube or the goal target if it exists</p></div>
</dd>
<dt id="main.planning.PathPlanning.Planning.turn_robot_around"><code class="name flex">
<span>def <span class="ident">turn_robot_around</span></span>(<span>self, center, angle, distance)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def turn_robot_around(self, center, angle, distance):
    &#34;&#34;&#34;
    Turns the robot around by -90 degrees
    &#34;&#34;&#34;

    vector = np.array([distance * np.cos(angle), distance * np.sin(angle)])
    vector = self.mat_rot(-np.pi / 2, vector)
    vector = vector / np.linalg.norm(vector) * distance
    return center + vector</code></pre>
</details>
<div class="desc"><p>Turns the robot around by -90 degrees</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="main.planning" href="index.html">main.planning</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="main.planning.PathPlanning.Planning" href="#main.planning.PathPlanning.Planning">Planning</a></code></h4>
<ul class="">
<li><code><a title="main.planning.PathPlanning.Planning.are_points_in_proximity" href="#main.planning.PathPlanning.Planning.are_points_in_proximity">are_points_in_proximity</a></code></li>
<li><code><a title="main.planning.PathPlanning.Planning.check_colision_from_class" href="#main.planning.PathPlanning.Planning.check_colision_from_class">check_colision_from_class</a></code></li>
<li><code><a title="main.planning.PathPlanning.Planning.check_colisions" href="#main.planning.PathPlanning.Planning.check_colisions">check_colisions</a></code></li>
<li><code><a title="main.planning.PathPlanning.Planning.clear_objects" href="#main.planning.PathPlanning.Planning.clear_objects">clear_objects</a></code></li>
<li><code><a title="main.planning.PathPlanning.Planning.create_path" href="#main.planning.PathPlanning.Planning.create_path">create_path</a></code></li>
<li><code><a title="main.planning.PathPlanning.Planning.find_intersection" href="#main.planning.PathPlanning.Planning.find_intersection">find_intersection</a></code></li>
<li><code><a title="main.planning.PathPlanning.Planning.find_tangent_points" href="#main.planning.PathPlanning.Planning.find_tangent_points">find_tangent_points</a></code></li>
<li><code><a title="main.planning.PathPlanning.Planning.generate_shoot_path" href="#main.planning.PathPlanning.Planning.generate_shoot_path">generate_shoot_path</a></code></li>
<li><code><a title="main.planning.PathPlanning.Planning.generate_trajectory" href="#main.planning.PathPlanning.Planning.generate_trajectory">generate_trajectory</a></code></li>
<li><code><a title="main.planning.PathPlanning.Planning.generate_way_around" href="#main.planning.PathPlanning.Planning.generate_way_around">generate_way_around</a></code></li>
<li><code><a title="main.planning.PathPlanning.Planning.identify_objects" href="#main.planning.PathPlanning.Planning.identify_objects">identify_objects</a></code></li>
<li><code><a title="main.planning.PathPlanning.Planning.is_goal" href="#main.planning.PathPlanning.Planning.is_goal">is_goal</a></code></li>
<li><code><a title="main.planning.PathPlanning.Planning.mat_rot" href="#main.planning.PathPlanning.Planning.mat_rot">mat_rot</a></code></li>
<li><code><a title="main.planning.PathPlanning.Planning.path_length" href="#main.planning.PathPlanning.Planning.path_length">path_length</a></code></li>
<li><code><a title="main.planning.PathPlanning.Planning.point_distance_from_line" href="#main.planning.PathPlanning.Planning.point_distance_from_line">point_distance_from_line</a></code></li>
<li><code><a title="main.planning.PathPlanning.Planning.same_hading" href="#main.planning.PathPlanning.Planning.same_hading">same_hading</a></code></li>
<li><code><a title="main.planning.PathPlanning.Planning.solve_more_blue_tubes" href="#main.planning.PathPlanning.Planning.solve_more_blue_tubes">solve_more_blue_tubes</a></code></li>
<li><code><a title="main.planning.PathPlanning.Planning.turn_robot_around" href="#main.planning.PathPlanning.Planning.turn_robot_around">turn_robot_around</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
